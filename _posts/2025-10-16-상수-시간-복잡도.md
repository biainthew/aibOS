---
layout: post
title: "상수 시간 복잡도"
date: 2024-10-07
categories: [general]
tags: [Java]
excerpt_separator: ""
---



### 상수 시간 복잡도

1. **간단한 연산**

    ```java
    int a = 10;
    int b = a + 5;  // 항상 동일한 시간에 수행됨 (O(1))
    ```

2. **HashMap에서의 get()** : 일반적으로 O(1) 시간 복잡도를 가진다 이는 키에 대한 해시 값을 계산하고 해당 버킷에서 값을 즉시 찾을 수 있기 때문이다

    ```java
    HashMap<String, Integer> map = new HashMap<>();
    map.put("Apple", 100);
    int value = map.get("Apple");  // O(1)
    ```


**O(1)의 의미**

- 데이터 크기와 무관 : O(1) 알고리즘은 데이터가 1개이든 1000개이든 100만개이든 동일한 시간 안에 작업을 수행한다
- 상수 시간 : 알고리즘이 어떤 고정된 상수 시간 내에 작업을 끝낸다는 의미이다 예를 들어 한 번 계산하고 끝난다 처럼 데이터를 한 번만 접근하고 종료하면 O(1)이다

**O(1)의 실제 예시**

- 배열에서 인덱스로 접근하기 : 배열에서 특정 인덱스에 있는 값을 가져오는 것은 O(1)이다 배열은 메모리 상에 연속적으로 저장되기 때문에 인덱스를 알면 바로 해당 값을 가져올 수 있다

    ```java
    int[] arr = {1, 2, 3, 4};
    int x = arr[2];  // O(1)
    ```

- 변수 할당 또는 단순 계산

    ```java
    int x = 10 + 5;  // O(1)
    ```


**O(1)과 다른 시간 복잡도와의 비교**

- **O(1)** : 상수 시간 복잡도 (입력 크기에 상관없이 일정)
- **O(log n)** : 로그 시간 복잡도 (입력 크기가 증가할수록 시간은 매우 천천히 증가)
- **O(n)** : 선형 시간 복잡도 (입력 크기에 비례해서 시간 증가)
- **O(n²)** : 이차 시간 복잡도 (입력 크기의 제곱에 비례해서 시간 증가)
