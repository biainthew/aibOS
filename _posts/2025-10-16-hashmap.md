---
layout: post
title: "HashMap"
date: 2024-10-07
categories: [general]
tags: [Java]
---


### 정의


Java의 `java.util` 패키지에 포함된 해시 테이블 기반의 자료구조로 키와 값을 매핑하는 데 사용된다


HashMap은 매우 유연하고 자주 사용되는 컬렉션 클래스 중 하나이다


### 특징

1. **Key-Value 구조**

    HashMap은 하나의 키에 하나의 값을 매핑한다 그래서 키를 통해 값을 빠르게 검색할 수 있다


    ```java
    HashMap<String, Integer> map = new HashMap<>();
    map.put("Apple", 100);
    map.put("Banana", 200);
    ```

2. **빠른 조회**

    HashMap은 내부적으로 해시 테이블을 사용하여 키의 해시 값을 계산한다 이를 통해 매우 빠른 상수시간복잡도로 값을 검색할 수 있다


    > 💡 **O(1) 시간 복잡도(상수 시간 복잡도, Constant Time Complexity)**  
    > 알고리즘이나 연산이 입력 크기와 무관하게 항상 일정한 시간 안에 실행된다는 것을 나타낸다  
    > 즉 입력 데이터의 크기나 양이 증가하더라도 실행 시간이 변하지 않는다

3. **Null 허용**

    HashMap은 null 키 및 null 값을 허용한다 즉 키나 값으로 null을 저장할 수 있다


    ```java
    map.put(null, 300);
    map.put("Orange", null);
    ```

4. **순서 보장 없음**

    HashMap은 데이터가 삽입된 순서를 보장하지 않는다 데이터를 저장하고 나서 순서대로 출력되지 않을 수도 있다 순서를 유지하려면 `LinkedHashMap`을 사용해야 한다

5. **동기화되지 않음**

    HashMap은 기본적으로 스레드 안전하지 않으므로 여러 스레드에서 동시에 접근할 경우 문제를 일으킬 수 있다 동기화가 필요한 경우 `Collections.synchronizedMap()`으로 동기화된 맵을 만들거나 `ConcurrentHashMap`을 사용하는 것이 좋다

6. **중복 키 허용 안됨**

    동일한 키로 여러 값을 저장할 경우 가장 마지막에 추가된 값으로 덮어씌워진다 


    ```java
    map.put("Apple", 100);
    map.put("Apple", 150); // 기존 값 100은 150으로 덮어씌워짐
    ```


### 주요 메서드

- **put(key, value)** : 키와 값을 맵에 저장한다 기존에 동일한 키가 있으면 덮어씌운다
- **get(Object key)** : 주어진 키에 해당하는 값을 반환한다 만약 키가 없다면 null을 반환한다
- **remove(Object key)** : 주어진 키에 해당하는 엔트리(키와 값의 쌍)를 맵에서 제거한다
- **containsKey(Object key)** : 주어진 키가 맵에 존재하는지 확인한다
- **containsValue(Object value)** : 주어진 값이 맵에 존재하는지 확인한다
- **keySet()** : 모든 키를 Set으로 반환

    ```java
    Set<String> keys = map.keySet();
    ```

- **values()** : 모든 값을 Collection으로 반환

    ```java
    Collection<Integer> values = map.values();
    ```

- **size()** : 맵에 저장된 키 값 쌍의 개수를 반환한다

    ```java
    int size = map.size();
    ```


### 내부 동작 원리

1. **해싱(Hashing)** : HashMap은 키의 해시 코드를 기반으로 값을 저장할 버킷(bucket)을 결정한다 키의 `hashCode()` 메서드를 사용해 해시 값을 계산한 후 이 값을 배열 인덱스로 변환하여 그 위치에 데이터를 저장한다
2. **해시 충돌** : 서로 다른 키가 동일한 해시 값을 가질 수 있다 이를 해시 충돌이라 하며 HashMap은 이를 처리하기 위해 체이닝(Chaining) 방식을 사용한다 체이닝은 동일한 버킷에 여러 엔트리를 연결 리스트로 저장하는 방식이다
3. **리사이징** : HashMap의 크기가 일정 수준에 도달하면 자동으로 크기를 늘린다 이는 load factor에 의해 제어되며 기본적으로 0.75이다 즉 맵이 75% 채워지면 자동으로 크기가 두 배가 된다

### 예시


```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();

        // 값 삽입
        map.put("Apple", 100);
        map.put("Banana", 200);
        map.put("Orange", 300);

        // 값 조회
        System.out.println("Apple 가격: " + map.get("Apple")); // 100

        // 키가 존재하는지 확인
        if (map.containsKey("Banana")) {
            System.out.println("Banana 가격: " + map.get("Banana")); // 200
        }

        // 값 수정
        map.put("Banana", 250);

        // 값 제거
        map.remove("Orange");

        // 맵 크기
        System.out.println("HashMap 크기: " + map.size()); // 2
    }
}
```

