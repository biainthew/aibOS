---
layout: post
title: "Vue basic 3"
date: 2023-02-21
categories: [general]
tags: [Vue]
excerpt_separator: ""
---



{% raw %}

### 🌼 계산된 속성 (computed)🌼


→ 반응적으로 계산되는 속성을 선언할 수 있음


→ `computed 속성`은 계산에 사용된 다른 반응형 상태를 의존성으로 추적 …? 뭔말임


→ 결과를 캐시하고 의존성이 변경되면 자동으로 업데이트 한다라 …


[설명](https://joshua1988.github.io/vue-camp/syntax/computed.html#computed-%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC-%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5)


→ 자바스크립트 계산식들이 많으면 가독성이 떨어지기 `때문에` 사용 / data 속성이 변했을 때 감지하고 자동으로 다시 연산해주는 `장점` / 인자를 받지 않고 http 통신같은 로직은 정의하지 않는다는 `주의점`


```javascript
<script>
let id = 0

export default {
  data() {
    return {
      newTodo: '',
      hideCompleted: false,
      todos: [
        { id: id++, text: 'HTML 배우기', done: true },
        { id: id++, text: 'JavaScript 배우기', done: true },
        { id: id++, text: 'Vue 배우기', done: false }
      ]
    }
  },
  computed: {
    filteredTodos(){
      return this.hideCompleted ? this.todos.filter((t) => !t.done) : this.todos
    } //computed 속성으로 filteredTodos 배열을 만들어주고
  },
  methods: {
    addTodo() {
      this.todos.push({ id: id++, text: this.newTodo, done: false })
      this.newTodo = ''
    },
    removeTodo(todo) {
      this.todos = this.todos.filter((t) => t !== todo)
    }
  }
}
</script>

<template>
  <form @submit.prevent="addTodo">
    <input v-model="newTodo">
    <button>Add Todo</button>
  </form>
  <ul>
    <li v-for="todo in filteredTodos" :key="todo.id">
//li 반복문 돌릴 배열을 수정
      <input type="checkbox" v-model="todo.done">
      <span :class="{ done: todo.done }">{{ todo.text }}</span>
      <button @click="removeTodo(todo)">X</button>
    </li>
  </ul>
  <button @click="hideCompleted = !hideCompleted">
    {{ hideCompleted ? 'Show all' : 'Hide completed' }}
  </button>
</template>

<style>
.done {
  text-decoration: line-through;
}
</style>
```


🤨 하단 버튼 누르면 체크박스 체크된 li 들은 배열에서 빠짐


### 🌼 생명주기와 템플릿 참조🌼


→ `ref` 를 사용하여 템플릿 참조 요청 가능


→ 엘리먼트는 `this.$refs.p` 로 노출되지만 컴포넌트가 **마운트된 후**에만 접근할 수 있음


→ 마운트 된 후 코드를 실행하려면 `mounted` 옵션을 사용해야 함


☝🏻 이것을 `컴포넌트 생명 주기 훅`이라고 하며 생명 주기의 특정 시간에 호출할 콜백을 등록할 수 있음 / `created` `updated` 같은 다른 훅도 있음


```javascript
<script>
export default {
  mounted() {
    this.$refs.p.textContent = '와우'
  }
}
</script>

<template>
  <p ref="p">안녕</p>
</template>
```


### 🌼 감시자 (watch) 🌼


→ `watch` 로 숫자가 변경될 때 콘솔에 숫자를 기록하는 등의 **반응형 사이드 이펙트** 수행 가능


```javascript
<script>
export default {
  data() {
    return {
      todoId: 1,
      todoData: null
    }
  },
  methods: {
    async fetchData() {
      this.todoData = null
      const res = await fetch(
        `https://jsonplaceholder.typicode.com/todos/${this.todoId}`
      )
      this.todoData = await res.json()
    }
  },
  mounted() {
    this.fetchData() //마운트 될 때 api 에서 할 일 데이터를 가지고 옴
  },
  watch: {
    todoId() {
      this.fetchData() //버튼을 클릭할 때 다음 할 일을 가져오는 감시자
    }
  }
}
</script>

<template>
  <p>할 일 id: {{ todoId }}</p>
  <button @click="todoId++">다음 할 일 가져오기</button> //클릭하면 id 증가
  <p v-if="!todoData">로딩...</p>
  <pre v-else>{{ todoData }}</pre>
</template>
```


### 🌼 컴포넌트 🌼


→ 일반적으로 실제 Vue 앱은 중첩된 컴포넌트를 사용하여 생성됨 / 상위 컴포넌트는 다른 컴포넌트를 템플릿의 하위 컴포넌트로 렌더링 할 수 있고 자식 컴포넌트를 사용하려면 먼저 가져와야 함


→ 그 뒤에 components 옵션을 사용하여 컴포넌트를 등록해야 함


```javascript
<script>
  import ChildComp from './ChildComp.vue'
export default {
  // 자식 컴포넌트를 등록
  components:{
    ChildComp
  }
}
</script>

<template>
  <!-- 자식 컴포넌트 렌더링 -->
  <ChildComp/>
</template>
```


### 🌼 props 🌼


→ 자식 컴포넌트는 `props` 를 통해 부모로부터 데이터를 받을 수 있음 / 우선 허용할 props 를 설정해야함


→ 일단 선언 되면 `prop` 이 `this` 에 노출되고 자식 컴포넌트의 템플릿에서 사용할 수 있음


→ 부모는 속성을 사용하는 것처럼 자식에게 `prop` 을 전달할 수 있음 동적 값을 전달하기 위해 `v-bind` 문법을 사용할 수도 있음


```javascript
<script>
import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  },
  props: {
    msg: String
  },
  data() {
    return {
      greeting: '부모 컴포넌트로부터 💌을 전달받았어요!'
    }
  }
}
</script>

<template>
  <ChildComp :msg="greeting"/>
</template>
```


{% endraw %}
