---
layout: post
title: "[SQLD]1-2. 데이터 모델링의 성능"
date: 2024-02-27
categories: [general]
tags: [Test]
excerpt_separator: ""
---



## 성능 데이터 모델링


### 정의


세 가지 경우 고려 : 데이터 모델 구조, 대용량의 데이터, 인덱스 특성


반 정규화만을 의미하지 않음, 정규화 또는 인덱스 특징 고려한 컬럼 순서 변형도 가능


데이터 특성에 따라 정규화된 모델의 테이블 수직 또는 수평분할 방법


논리적 테이블을 물리적 전환할 때 데이터 처리 성격에 따라 변환


### 수행시점


사전에 할 수록 비용절감이 가능


분석/설계 단계에서 하는 것이 베스트(재 업무비용 최소화)


### 고려사항


데이터 모델링 할 때 정규화 수행


데이터 베이스 용량산정 수행


데이터 베이스에 발생되는 트랜잭션 유형 파악


용량과 트랜잭션 유형에 따라 반정규화 수행


이력모델 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 수행


성능관점에서 데이터 모델 검증


## 정규화와 성능


### 정규화


다양한 유형의 검사를 통해 데이터 모델을 좀 더 구조화하고 개선시켜 나가는 절차


중복성 제거, 관심사별로 처리되는 경우가 많아 성능이 향상됨


성능 = 조회/입력, 수정, 삭제 두가지로 분류


결정자에 의해 함수적 종속 가진 일반속성을 의존자로 하여 입력/수정/삭제, 이상제거, 중복속성 제거, 결정자에 의해 동일한 의미의 일반속성 하나의 테이블로 집약


한 테이블의 데이터 용량 최소화, 입력/수정/삭제 → 향상, 조회 → 향상 or 저하


반정규화된 테이블의 성능이 더 떨어지는 경우 존재


## 반정규화와 성능


### 반정규화


정규화된 엔티티 속성, 관계에 대하여 시스템의 성능향상, 개발과 운영 단순화를 위하여 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법(데이터 중복하여 성능 향상)


무결성 깨질 위험 감수 → 디스크 I/O량 감소, 긴 경로의 조인으로 인한 성능저하 해결, 중복성의 원리를 활용하여 데이터 조회시 성능 향상


정규화도 조회 성능 향상 하지만 일부 여러 조인 걸려야 데이터 가져오는 경우(비식별관계)


→ 조회에 대한 처리성능 중요하다고 판단되면 부분적 반정규화
    정규화의 종속관계는 위반하지 않고 데이터 중복성을 증가시켜 조회 성능 향상


### 반정규화 적용방법

1. 반정규화 대상조사 : 범위처리 빈도수, 대량 범위처리, 통계성 프로세스, 테이블 조인 개수
2. 다른 방법 검토 : 뷰 테이블, 클러스터링, 인덱스 조정, 응용 어플리케이션
3. 반정규화 적용 : 테이블, 속성, 관계의 반정규화

### 반정규화 기법


**테이블 반정규화**


테이블 병합 : 1:1 관계 병합, 1:N 관계 병합, 슈퍼/서브타입 병합


테이블 분할 : 수직분할 (컬럼단위, 테이블 1:1로 분리), 수평분할(로우단위)


테이블 추가


    중복 테이블 - 동일한 테이블구조 중복 원격조인 제거


    통계 테이블 - SUM, AVG 등 미리 계산, 조회 시 성능 향상


    이력 테이블 - 마스터 테이블 레코드 중복하여 이력테이블에 존재


    부분 테이블 - 전체 컬럼 중 자주 이용하는 컬럼들을 모아놓은 별도 테이블


**컬럼 반정규화**


중복컬럼 추가 : 조인을 감소시키기 위해 중복컬럼 위치시킴


파생컬럼 추가 : 계산에 의한 성능저하 예방, 미리 계산하여 컬럼에 보관(Derived 컬럼)


이력테이블 컬럼추가 : 기능성 컬럼(최근값 여부, 시작 및 종료일자 등) 추가


PK에 의한 컬럼추가 : 복합의미 PK 단일속성 구성 시 발생, 일반속성으로 PK 데이터 추가


응용시스템 오작동 위한 컬럼추가 : 이전 데이터 임시적 중복보관(원래값 복구 용도)


**관계 반정규화**


중복관계 추가 : 여러 경로를 거친 조인을 방지하기 위해 추가적인 관계를 맺음


테이블과 컬럼의 반정규화는 데이터 무결성에 영향을 미침


관계의 반정규화는 데이터 무결성 깨뜨릴 위험 없음, 데이터 처리 성능은 향상


정규화가 잘 정의된 데이터 모델에서 성능이 저하된 경우 존재


## 대량 데이터에 따른 성능


### 대량 데이터 발생에 따른 테이블 분할


수직분할 : 컬럼 단위로 분할하여 I/O 경감


수평분할 : 로우 단위로 분할하여 I/O 경감


### 성능 저하의 원인


하나의 테이블에 데이터 대량집중 : 데이블 구조 너무 커져 효율성 낮아짐, 디스크 I/O 높아짐


하나의 테이블에 여러개의 컬럼 존재 : 디스크 점유량 높아짐, 데이터 읽는 I/O량 높아짐


대량의 데이터가 처리되는 테이블 : SQL 문장에서 데이터 처리 위한 I/O량 높아짐, 인덱스 구성


대량의 데이터가 하나의 테이블에 존재 : 인덱스의 크기 커짐, 성능저하


컬럼이 많아지는 경우 : 로우 체이닝, 로우 마이그레이션 발생


### 해결방안


한 테이블 많은 컬럼 - 수직 분할


대량 데이터 저장 및 처리 - 파티셔닝(Range(날짜/숫자별), List(특정 값, 지역), Hash), PK에 의한 테이블 분할


### 테이블에 대한 수직/수평분할 절차


데이터 모델 완성


데이터베이스 용량 산정


대량의 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석


컬럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 발생하는지 분석하여 테이블 분리


컬럼 수 많을 경우 → 1:1 형태 수직 분할


컬럼 수 적지만 데이터 용량 많을 경우 → 파티셔닝 고려


## 데이터베이스 구조와 성능


### 슈퍼/서브타입 데이터 모델


최근 가장 많이 쓰임


업무를 구성하는 데이터를 공통/차이점 특징 고려 효과적 표현 가능


**슈퍼타입** : 공통의 부분


**서브타입** : 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성


논리적 데이터 모델에서 이용되는 형태(분석단계에서 많이 쓰임)


물리적 데이터 모델로 설계시 문제점 나타남(적당한 노하우 x → 1:1 또는 All in one 타입이 되어버려 성능 저하)


### 성능 저하의 원인


트랜잭션은 일괄처리, 테이블은 개별로 유지되어 Union 연산에 의해 성능 저하


트랜잭션은 서브타입 개별로 처리, 테이블은 하나로 통합되어 불필요한 많은 데이터


트랜잭션은 슈퍼+서브타입을 공통으로 처리, 테이블은 개별로 유지됨 or 하나로 집약


### 슈퍼/서브타입의 변환 기준


데이터의 양과 해당 테이블에 발생되는 트랜잭션 유형


데이터가 소량 : 데이터 처리 유연성 고려하여 가급적 1:1 관계 유지


데이터가 대량 : 개별 테이블, 슈퍼+서브타입 테이블, 하나의 테이블


### 슈퍼/서브타입의 데이터 모델 변환기술


개별로 발생되는 트랜잭션 → 개별 테이블로 구성(One to one type)


슈퍼+서브타입에 대해 발생되는 트랜잭션 → 슈퍼+서브타입 테이블로 구성(Plus type)


전체를 하나로 묶어 트랜잭션 발생 → 하나의 테이블로 구성(Single type)


쪼개질 수록 확장성 $\uparrow$ 조인 성능 $\downarrow$ I/O 성능 $\uparrow$ 관리 용이성  $\downarrow$


### PK/FK 컬럼 순서와 성능 개요


인덱스 중요성 : 데이터 조작시 가장 효과적으로 처리될 수 있도록 접근경로 제공 오브젝트


PK/FK 설계 중요성 : 데이터를 접근할 때 접근경로 제공, 설계단계 마지막에 컬럼순서 조정


PK 순서의 중요성 : 물리적인 모델링 단계에서 스스로 생성 PK 이외에 상속 PK 순서도 주의


FK 순서의 중요성 : 조인의 경로 제공 역할 수행, 조회 조건 고려하여 반드시 인덱스 생성


### PK 순서를 조정하지 않으면 성능 저하되는 이유


조회 조건에 따라 인덱스를 처리하는 범위가 달라짐


PK의 순서를 인덱스 특징에 맞게 생성하지 않고 자동으로 생성하게 되면 테이블에 접근하는 트랜잭션이 비효율적인 인덱스에 의하여 인덱스를 넓은 범위로 스캔하거나 풀스캔 유발


### 물리적 테이블에 FK 제약이 걸려있지 않을 경우 인덱스 미생성으로 성능 저하


물리적으로 두 테이블 사이에 FK 참조 무결성 관계를 걸어 상속받은 FK에 대해 인덱스 생성


## 분산 데이터베이스


### 개요


빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역에서 노드로 위치시켜 사용성과 성능을 극대화 시킨 데이터베이스


분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스


논리적으로 동일한 시스템, 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임


물리적 Site 분산, 논리적으로 사용자 통합 및 공유


### 투명성


분할 투명성(단편화) : 하나의 논리적 릴레이션을 여러 단편으로 분할, 그 사본을 여러 Site 에 저장


위치 투명성 : 사용하려는 데이터의 저장 장소 알 필요 없음, 위치정보 시스템 카탈로그에 유지


지역사상 투명성 : 지역 DBMS, 물리적 DB 사이 Mapping 보장, 각 지역시스템 이름과 무관한 이름 사용 가능


중복 투명성 : DB객체가 여러 Site 에 중복되어 있는지 알 필요 없음


장애 투명성 : 구성요소(DBMS, 컴퓨터)의 장애에 무관하게 트랜잭션 원자성 유지


병행 투명성 : 다수 트랜잭션 동시 수행 시 결과의 일관성 유지


### 적용방법


단순히 분산 환경에서 데이터베이스를 구축하는 것이 목적이 아니라 업무의 특징에 따라 데이터베이스 분산구조를 선택적으로 설계


### 장점


지역자치성, 점증적 시스템 용량 확장


신뢰성과 가용성


효용성과 융통성


빠른 응답 속도와 통신비용 절감


데이터의 가용성과 신뢰성 증가


시스템 규모의 적절한 조절


각 지역 사용자의 요구 수용 증대


### 단점


소프트웨어 개발 비용


오류의 잠재성 증대


처리 비용의 증대


설계, 관리의 복잡성과 비용


불규칙한 응답속도


통제의 어려움


데이터 무결성에 대한 위협


### 활용 방향성


업무적인 특징에 따라 위치 중심의 분산, 업무 필요에 의한 분산을 설계


### 가치


통합된 데이터 베이스에서 제공할 수 없는 빠른 성능을 제공


(원거리 또는 다른 서버에 접속하여 처리함으로 인해 발생되는 네트워크 부하 및 트랜잭션 집중에 따른 성능 저하의 원인을 분산된 데이터베이스 환경을 구축하여 빠른 성능 제공)


### 테이블 위치 분산


테이블 구조 변경 x


테이블이 다른 데이터베이스에 중복으로 생성 x


정보를 이용하는 형태가 각 위치별로 차이가 있을 경우 사용


테이블 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서 필요


### 테이블 분할 분산


위치만 다른 곳에 두는 것이 아니라 각각의 테이블을 쪼개어서 분산


**수평분할**


    특정 컬럼의 값 기준으로 로우 단위 분리


    컬럼은 분리 x


    PK 에 의해 중복이 발생 x


    자사별로 사용하는 Row 가 다를 때 사용


    데이터 수정 : 타 지사에 있는 데이터 원칙적으로 수정 x, 자신 데이터만 수정


    각 지사의 테이블 통합처리 : 조인 이 발생하여 성능저하 예상, 통합처리 프로세스가 많은지 검토한 후 많지 않은 경우 수평분할 진행


    데이터 무결성 보장 : 데이터가 지사별로 별도로 존재하므로 중복발생 x, 타 지사 데이터의 지사구분이 변경되면 단순히 수정이 발생하는 것 이외에 변경된 지사로 데이터를 이송해야 함, 한 시점에는 한 지사에서 하나의 데이터만 존재


    지사별로 데이터를 운영하는 경우 : 데이터베이스가 속한 서버가 지사에서 존재하든지 본사에 통합해서 존재하든지 간에 데이터베이스 테이블들은 수평분할하여 존재


**수직분할**


    컬럼을 기준으로 컬럼 단위로 분리


    로우 단위로 분리 x


    각 테이블은 동일한 기본키 구조와 값을 가지고 있어야 함


    데이터를 한군데 집합시켜 놓아도 동일한 기본키는 하나로 표현하면 되므로 데이터 중복이 발생되지 않음


    테이블 전체 컬럼 데이터 조회 : 가능하면 통합하여 처리하는 프로세스가 많은 경우에는 이용하지 않도록 한다


    실제 프로젝트에서 수직분할 분산 환경을 구성하는 사례는 드물다


### 테이블 복제 분산


동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리


프로젝트에서 많이 사용하는 데이터베이스 분산 기법


**부분복제**


    마스터 데이터베이스에서 테이블의 일부 내용만 다른 지역이나 서버에 위치


    통합된 테이블을 본사에 가지고 있으면서 각 지사별로는 지사에 해당하는 로우를 가지고 있는 형태(본사 데이터 = 지사 데이터들의 합)


    여러 테이블에 조인이 발생하지 않는 빠른 작업 수행 가능(각 지사에서 데이터 처리 용이할 뿐 아니라 전체 데이터 통합처리도 본사의 통합 테이블 이용)


    본사 데이터는 통계, 이동 등 관리 / 지사 데이터 이용하여 지사별 빠른 업무


    지사에 데이터가 선발생, 본사는 지사 데이터 통합하여 발생(광역복제와 차이)


    다른 지역간 데이터 복제는 실시간 처리보다 배치 처리를 이용(시간, 부하 $ 
    \uparrow$)


    데이터의 정합성 일치 어려움 가능하면 [지사 수정 발생 → 본사 복제] 권장


**광역복제**


    통합된 테이블을 본사에 가지고 있으며 각 지사에 본사와 동일한 데이터 분배


    본사나 지사나 데이터 처리에 특별한 제약 없음


    본사에서 데이터 입력, 수정, 삭제가 되어 지사에서 이용(부분복제와 차이)


    다른 지역간 데이터 복제는 실시간 처리보다 배치 처리를 이용(시간, 부하 $ 
    \uparrow$)


### 테이블 요약 분산


지역/서버간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우


**분석요약**


각 지사별로 존재하는 요약 정보를 본사에 통합하여 다시 전체에 대해 요약


동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식


테이블에 있는 모든 컬럼과 로우가 지사에도 동일하게 존재하지만 각 지사에는 동일한 내용에 대해 지사별로 요약된 정보를 가지고 있고 본사에는 각 지사의 요약 정보를 통합하여 재산출한 전체 요약정보를 가짐


각종 통계 데이터 산정 : 모든 지사의 데이터를 이용하여 처리하면 성능이 지연되고 각 지사의 서버에 부하, 업무장애 발생 가능


지사에 있는 데이터를 이용하면 본사에서 통합하여 요약 데이터 산정


통합 통계 데이터에 대한 정보제공에 용이


본사에 분석 요약된 테이블을 생성하고 데이터는 역시 일반 업무가 종료되는 야간에 수행하여 생성


**통합요약**


각 지사별로 존재하는 다른 내용 정보를 본사에 통합, 다시 전체의 요약 산출


테이블에 있는 모든 컬럼과 로우가 지사에도 동일하게 존재하지만 각 지사에는 타 지사와 다른 요약정보를 가지고 있고 본사에는 각 지사의 요약 정보를 데이터를 같은 위치에 두는 것으로 통합하여 전체 요약 정보 가짐


지사에서 요약한 정보를 본사에서 취합, 각 지사별 데이터 비교하기 용이, 통계 데이터에 대한 정보 제공에 용이


본사에 통합 요약된 테이블을 생성하고 데이터는 역시 일반 업무가 종료되는 야간에 수행하여 생성


### 분산 데이터베이스를 적용하여 성능이 향상된 사례


분산 환경의 원리를 이해하지 않고 데이터베이스를 설계하여 성능이 저하되는 경우 빈번


복제분산의 원리를 간단히 응용하면 많은 업무적 특성이 있는 곳에서 성능 향상해 설계 가능


### 데이터베이스 분산 설계를 적용하면 효과적인 부분


- 성능이 중요한 사이트


- 공통코드, 기준정보, 마스터 데이터 등에 대해 분산 환경을 구성하면 성능이 좋아짐


- 실시간 동기화가 요구되지 않을 때 좋음 (준 실시간의 업무적 특징을 가져도 분산 환경 구성 가능)


- 특정 서버에 부하가 집중될 때 부하를 분산시키는 용도록 좋다


- 백업 사이트(Disaster recovery site) 구성 시 간단하게 분산 기능 적용하여 구성 가능

