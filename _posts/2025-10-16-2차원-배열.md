---
layout: post
title: "2차원 배열"
date: 2025-10-03
categories: [general]
tags: [C]
excerpt_separator: ""
---



### 1. 기본 개념


```c
int arr[i][j]
```


→ `i` 는 행 개수, `j` 는 열 개수를 의미한다. 따라서 총 `i*j` 개의 값 저장 가능


```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```


→ 행과 열을 맞춰서 작성해보면 이렇게 되지만 실제로 메모리에는 아래처럼 일렬로 저장된다


```c
[1][2][3][4][5][6][7][8][9][10][11][12]
 ↑________↑ ↑_________↑  ↑_________↑
 0행         1행          2행
```


### 2. 선언 방법

1. 크기만 지정

```c
int arr[3][4];  
// 쓰레기 값으로 채워짐
```

1. 완전한 초기화

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

1. 부분 초기화

```c
int arr[3][4] = {
    {1, 2},        
// {1, 2, 0, 0}

    {5},           
// {5, 0, 0, 0}

    {9, 10, 11}    
// {9, 10, 11, 0}

};

// 나머지는 자동으로 0으로 채워짐
```

1. 1차원처럼 초기화

```c
int arr[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

// 자동으로 행별로 나눠서 저장됨
```

1. 행 크기 생략 (초기화와 함께 쓸 때만 가능)

```c
int arr[][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
};

// 행 크기는 자동으로 2가 됨
```


### 3. 접근 방법


```c
int* row = arr[1];
printf("%d", row[2]); // arr[1][2]와 동일
```


→ **이렇게 되는 이유**


`arr[1]` 은 1행 0번째 원소의 주소값을 가진다 (배열 이름은 포인터로 반환되기 때문에)


그래서 `row[0]` 의 주소값은 `arr[1][0]` 과 동일하고 `row[2]` 의 주소값은 `arr[1][2]` 의 주소값과 동일


이걸 식으로 표현해보면


```c
&row[0] == &arr[1][0]
&row[2] == &arr[1][2]

// 따라서
row[2] == arr[1][2]
```


### 4. 포인터와의 관계


```c
int arr[3][4];

// arr[0][0]의 주소값은 100, 값은 1이 저장되어 있다고 가정
arr        // 주소값 100 / int (*)[4] 타입 - 크기 4인 int 배열을 가리키는 포인터
arr[0]     // 주소값 100 / int* 타입 - 첫 번째 행의 시작 주소
arr[0][0]  // 값 1      / int 타입 - 실제 값
&arr[0][0] // 주소값 100 / 첫 번째 원소의 주소
```


**포인터 연산 비교**


```c
// arr[0][0]의 주소값은 100, arr[0][1]의 주소값은 101, arr[1][0]의 주소값은 200 이라고 가정
arr + 1          // 주소값 : 200 / 한 행 전체를 건너뜀
arr[0] + 1       // 주소값 : 101 / int 하나 건너뜀
&arr[0][0] + 1   // 주소값 : 101 / int 하나 건너뜀
```


→ 모두 같은 100이라는 주소값을 가지지만 +1 연산 시 이동하는 크기가 다르다

