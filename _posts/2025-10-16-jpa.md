---
layout: post
title: "Jpa"
date: 2025-07-17
categories: [general]
tags: [Sql]
excerpt_separator: ""
---



```shell
set JAVA_HOME=C:\dev\jdk-17.0.2
set PATH=%JAVA_HOME%\bin;%PATH%
```


### JPA 왜 쓰냐?


안 쓰면 자바 객체를 SQL로 변환, SQL을 자바 객체로 변환 -> 이 과정을 계속 반복해야 함


### 메모


객체는 참조로 연관관계를 맺는다


**ORM** : 객체와 관계형 DB를 매핑


### JPQL 왜 쓰냐 ?


JPA를 사용하면 엔티티 객체를 중심으로 개발하게 되는데 검색 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색함


=> 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능


=> 어플리케이션이 필요한 데이터만 불러오려면 검색 조건이 포함된 SQL이 필요


### 영속성 컨텍스트


엔티티를 영구 저장하는 환경


`EntityManager.persist(entity);`


=> 저장이 되는게 아니라 사실 영속성 컨텍스트가 생성됨 그리고 저장은 커밋하는 시점에 됨


이점 ?


캐싱 가능 => DB에서 조회하지 않고 1차 캐시에서 조회 가능


영속 엔티티의 동일성 보장


~ 섹션 4


### 엔티티 매핑


_`<property name="hibernate.hbm2ddl.auto" value="create" />`_


: 데이터베이스 스키마 자동 생성


- 개발 초기 단계는 create, update


- 테스트 서버는 update, validate : 사실 update도 안 쓰는게 좋긴 함


- 운영 서버는 validate, none


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/d1635e83-02bd-42e7-a238-520ed8924cc4/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4663CW6OS4F%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T112428Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHQaCXVzLXdlc3QtMiJHMEUCIQCXCoBASWQOwI%2F9mhUKcvZZvfk74V68HUJtv6DqVznHTgIgLvBYx0wrmFGNp13R0y%2FE9n5UYMH53oZj30oUwzeCrOYq%2FwMIPBAAGgw2Mzc0MjMxODM4MDUiDEfhN1MxrL1S7%2Fv%2BJircA%2B8cBdhtM%2FvzknUAwrULktToUKcPffrRZllfu9DcM6U7%2BBZXse2%2B%2BO9mEvXgdoCKD6%2B4L%2FqBavb0d8TypNcijwWy79TyN2MmEaVWpzidAxpbYOpsDZVIQhT95GXZplw3o79EDRyrSh9RyDnXGFUfpvotaAMZ0a02RctpydMLRnk%2BTnn6umSl2QK%2FmUbdum%2Fx5Pzm0O6yV4LXPtqPO7MhwssI6Ej2t%2FhwoFMuhS6gIh%2FyxOqjhCi1qDbnaUXAlY85mVFWTtg69JLVhFbUC4p853v%2BqgvtwKOccO3cLzm6I6DRHnrZ98fApYLJWqGOCX%2FKD%2B%2Fs77%2Bj8Ts924RIW9eX0H0gU6%2F5pmFMa1HjG1%2FLnRQsl79Hk8DCK7rjhjoGqOmhn9q6vK8EZY4UAv%2FnawT3Prifz22q7h%2BdS7esrAavCHKWmTo4vYEfoLBm8hffNmWNioJg4iYeQIVLBjgX6zMnFwu4zO%2FjUmxTtadBg9H0Bbhd2yW7amk%2FzN8trEamFwN9Oqu3wt0DbSeRnbVwsYJTZQDKyLLnctRH8pIhFqz4i2EZTLhoNkqsrg82H3PnybAg%2B0hZ0TNSWccY7fNVJPqnT9SLR043dHy1jHaHOAu0xvwXheV%2BzhUKXfECB8YGMJKb3csGOqUBUAUYyhe0xPKQFwbIJ3p5OVxfBCwnpy3bvlED9A1XgCeO3JMx7ufXebbDfOZqsFYbljZanEHbZgcCmvGQZGt7FxM9yK%2FK8fnUTR4opdSrT%2B0grk7KWF51lspBxaq8BQ4yjDgGKs4KqWZbygrnWH6qWblFBqK%2BYZr67wlmlryf7gp9IltAz1k0OPMjVtBv65P5O8U4rYTjOscyTu%2BkR%2Fs8EeJHkuE1&X-Amz-Signature=bc4af3609a701bf3504e6a93699f51f052153e3c6006a096b9e2622c04c6314d&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


> 💡 **unique 속성을 잘 사용하지 않는 이유**❓  
> `unique = true` 로 생성하면 이름이 랜덤하게 생성돼서 나중에 에러 발생 시 알아보기 어려움  
>   
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/51e764a1-fa53-482b-9289-8936c57340cf/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4663IMNPLPG%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T112428Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHQaCXVzLXdlc3QtMiJHMEUCIQCEaV9ihcm8X57fal%2FNO9qSCUGlcct%2BWukfSpYtZev7MgIgW%2BSLq50bhlX%2BdeG%2BzdI%2BDjeyMzKI1KkSbpEENTUdWdgq%2FwMIPBAAGgw2Mzc0MjMxODM4MDUiDBgrSYcI%2F%2BIgoSqOOyrcA3ds2bBEmTjGSIEtjkJz4%2F%2Fn1PlEcxjw2JvyeGsx2nmIwEOQCidmt7TnRS8WgKmHut%2F8uamONEowA%2FXAJ5Vm7XMkbzj%2BzjZTw1S2Urag3YotrSe5t4I%2BUurK6KcuMdY085FqqpzidmM1lkzVlbKK4OwkiCb9fqQMqAMf9sdQJVYCFpCfc1dx2FtaUa8rtdGZH2PWkr2ki4j%2FquGZPL%2FKY9bnRneIk3%2BLFJaSmj%2FPREK%2BFcUWqOeS05hR18wWC4VlpkGPO2WavoJ1dfDjnAG4buCpGVfDGFNfardiVEQqQqsCPXwqmBSkH6GbZdNpwwp4VDqZhEvbujoFCMFtMVBKa65JNPPDtyHSa9OiUkEjkDOor%2B80JTLz5CPLNe%2BRfvtTCeOOMKqN4re6LDPYawvRCv4U6b2SdXs6xdMMpiKhTL8MRFq86pQjrv%2B4xT94PD5L8uu0GPFXqI40WDt%2FPQzt0c5ISJgXt%2BXmhGtKnhnT2lSvcs%2BbItO%2FvdvSXRRXmFbPjslQPY5SNcac%2FmOYFbbXKxSTDZP8mhnFOlNzEubCOEYisXC6CStILe33JEBmqKRV%2BIosuXvNQV%2BzTqzJrXJkGdBfUqoG7DAn5pAWILWJaBKNNCj2GniuMxnCiHwvMPCa3csGOqUBZjUeCng0ZVdgAfa%2Bo2ua51Kk004rEr121gZsyfL8%2FnP8yaOV%2BHc7Zp%2F%2BQ6Oc2mkxa2M52KIXZQvEmaHhjx6KRleKnH5UDx6qx4%2BCJrxrh0%2BdBRRt75n%2Bq0vuOE9UQfUxvOvvpmvgDoOBsNsjWs8L%2FBvHvO17foDAkew3vO5cG6VMXOBWVxGlEDMENv3CREHdt8%2BfXZuz7nBQR5kkUqCGk6BPoG%2Be&X-Amz-Signature=0b1c9fb9c4ee4901e28387b8133586b2cfa88211f02afac9e0c43a75253d488f&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)  
>   
> 그래서 테이블 어노테이션에서 유니크 제약조건 이름을 직접 설정하는 방법을 사용함  
>   
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/3c6aff65-21c4-4bc6-bb9d-9e278a10971c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4663IMNPLPG%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T112428Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHQaCXVzLXdlc3QtMiJHMEUCIQCEaV9ihcm8X57fal%2FNO9qSCUGlcct%2BWukfSpYtZev7MgIgW%2BSLq50bhlX%2BdeG%2BzdI%2BDjeyMzKI1KkSbpEENTUdWdgq%2FwMIPBAAGgw2Mzc0MjMxODM4MDUiDBgrSYcI%2F%2BIgoSqOOyrcA3ds2bBEmTjGSIEtjkJz4%2F%2Fn1PlEcxjw2JvyeGsx2nmIwEOQCidmt7TnRS8WgKmHut%2F8uamONEowA%2FXAJ5Vm7XMkbzj%2BzjZTw1S2Urag3YotrSe5t4I%2BUurK6KcuMdY085FqqpzidmM1lkzVlbKK4OwkiCb9fqQMqAMf9sdQJVYCFpCfc1dx2FtaUa8rtdGZH2PWkr2ki4j%2FquGZPL%2FKY9bnRneIk3%2BLFJaSmj%2FPREK%2BFcUWqOeS05hR18wWC4VlpkGPO2WavoJ1dfDjnAG4buCpGVfDGFNfardiVEQqQqsCPXwqmBSkH6GbZdNpwwp4VDqZhEvbujoFCMFtMVBKa65JNPPDtyHSa9OiUkEjkDOor%2B80JTLz5CPLNe%2BRfvtTCeOOMKqN4re6LDPYawvRCv4U6b2SdXs6xdMMpiKhTL8MRFq86pQjrv%2B4xT94PD5L8uu0GPFXqI40WDt%2FPQzt0c5ISJgXt%2BXmhGtKnhnT2lSvcs%2BbItO%2FvdvSXRRXmFbPjslQPY5SNcac%2FmOYFbbXKxSTDZP8mhnFOlNzEubCOEYisXC6CStILe33JEBmqKRV%2BIosuXvNQV%2BzTqzJrXJkGdBfUqoG7DAn5pAWILWJaBKNNCj2GniuMxnCiHwvMPCa3csGOqUBZjUeCng0ZVdgAfa%2Bo2ua51Kk004rEr121gZsyfL8%2FnP8yaOV%2BHc7Zp%2F%2BQ6Oc2mkxa2M52KIXZQvEmaHhjx6KRleKnH5UDx6qx4%2BCJrxrh0%2BdBRRt75n%2Bq0vuOE9UQfUxvOvvpmvgDoOBsNsjWs8L%2FBvHvO17foDAkew3vO5cG6VMXOBWVxGlEDMENv3CREHdt8%2BfXZuz7nBQR5kkUqCGk6BPoG%2Be&X-Amz-Signature=289b092f673e65a176563700f9d268dd6b308809b259d13ecab7dba28618b616&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


Enumerated  는 type 을 Ordinal과 String중에 선택할 수 있는데 무조건 String 사용해야 함


lob은 지정할 수 있는 속성이 없음 문자면 clob 아니면 blob 자동으로


### 기본키 매핑


@Id


직접 할당


@GeneratedValue


자동 생성 (sequence, …)

1. strategy - GenerationType.IDENTITY
db가 알아서 해줌, 시퀀스같은
예외적으로 커밋하는 시점에 쿼리 날리는게 아니라 em.persist 실행했을 때 바로 디비에 insert 쿼리 날림
⇒ 모아서 insert 불가하다는게 단점, 성능에는 크게 차이 없
2. strategy - GenerationType.SEQUENCE
시퀀스는 long을 쓰는게 정석
이렇게 하면 자동으로 생성되는데 @SequenceGenerator 를 써서 이름 지정 가능
얘도 db에 가봐야 값을 알 수 있음
em.persistence 할 때 시퀀스 값을 조회 > 영속성 컨텍스트에 저장 > 커밋 전까지 디비에는 값 저장 X
⇒ 버퍼링 가능
    1. @SequenceGenerator
    name 지정하고 컬럼에서 generator 에 그 name 넣으면 됨
    allocationSize : 50 설정하면 한 번 실행했을 때 50개까지 미리 만들어두고 그 다음부터는 메모리에 있는 값으로 가져옴 성능

@TableGenerator
솔직히 잘 쓰진 않음 시퀀스 생성용 테이블, 시퀀스 이름이랑 값이 있음


**권장하는 식별자 전략**


long 형 + 대체키(UUID) 키 생성전략 사용 ( 자연키 ex. 주민등록번호 도 적절하지 않을 수 있다)


### 연관관계


객체를 테이블에 딱 맞춰서 모델링 하면 (ex. 외래키 등 이용해서) 객체지향스럽지 않고 관계형디비스러움, 객체는 참조를 사용하기 때문에

- 단방향 연관관계
    - 한쪽으로만 참조
- 양방향 연관관계
    - 양쪽으로 참조
    - 연관관계 주인 : 양쪽 중에서 하나를 주인으로 설정하고 걔만 외래키를 관리(등록, 수정), mapped by는 주인이 아닐 때 지정, 외래키가 있는 곳을 주인으로 지정해야함(DB 테이블 n 쪽인 곳)
    - 값은 연관관계의 주인에 넣어야 함 안그러면 외래키 값이 null로 들어감
    - 근데 사실 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는게 좋음
        - 양쪽에 설정하지 않았을 경우에는 commit 전에 조회할 경우 영속성 컨텍스트때문에 select 쿼리가 나가지 않고 캐시에서 조회하기 때문에 값이 있는데 없다고 나올 수 있음
    - 컨트롤러에서는 엔티티를 반환하면 안됨 (dto로 변환해서 반환하기)
        - 무한루프 생길 수 있음 (toString, lombok, …
        - 엔티티 변경하는 순간 api 스펙이 변경됨
    - 단방향 매핑으로 다 끝낸다는 생각으로 하기 그리고 꼭 필요할 때 양방향 매핑 추가

### 다양한 연관관계 매핑

- 다대일
    - 다 인 쪽에 외래키가 있음 > 얘가 연관관계 주인
    - 다 인 쪽에 @ManytoOne @JoinColumn(name=””)
    - 1 인 쪽에 @OnetoMany(mappedBy=””)
- 일대다
    - 일단 권장 안함
    - 1인 쪽이 주인
    - 일대 다일 때 양방향 하고싶으면 다인 쪽에 insertable false, updatable false 넣으면 됨
- 일대일
    - 다대일 단방향과 비슷, 어노테이션만 다름
    - 내 엔티티의 외래키는 내가 직접 관리해야 함
- 다대다
    - 실무에서 쓰면 안됨
    - 연결 테이블을 생성해서 사용함
    - 다대일로 변경해서 사용해야함 (연결 테이블을 엔티티로 승격해서 사용해야 함)
