---
layout: post
title: "Jpa"
date: 2025-07-17
categories: [general]
tags: [Sql]
excerpt_separator: ""
---



```shell
set JAVA_HOME=C:\dev\jdk-17.0.2
set PATH=%JAVA_HOME%\bin;%PATH%
```


### JPA 왜 쓰냐?


안 쓰면 자바 객체를 SQL로 변환, SQL을 자바 객체로 변환 -> 이 과정을 계속 반복해야 함


### 메모


객체는 참조로 연관관계를 맺는다


**ORM** : 객체와 관계형 DB를 매핑


### JPQL 왜 쓰냐 ?


JPA를 사용하면 엔티티 객체를 중심으로 개발하게 되는데 검색 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색함


=> 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능


=> 어플리케이션이 필요한 데이터만 불러오려면 검색 조건이 포함된 SQL이 필요


### 영속성 컨텍스트


엔티티를 영구 저장하는 환경


`EntityManager.persist(entity);`


=> 저장이 되는게 아니라 사실 영속성 컨텍스트가 생성됨 그리고 저장은 커밋하는 시점에 됨


이점 ?


캐싱 가능 => DB에서 조회하지 않고 1차 캐시에서 조회 가능


영속 엔티티의 동일성 보장


~ 섹션 4


### 엔티티 매핑


_`<property name="hibernate.hbm2ddl.auto" value="create" />`_


: 데이터베이스 스키마 자동 생성


- 개발 초기 단계는 create, update


- 테스트 서버는 update, validate : 사실 update도 안 쓰는게 좋긴 함


- 운영 서버는 validate, none


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/d1635e83-02bd-42e7-a238-520ed8924cc4/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466YJDXWSCY%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T105445Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHIaCXVzLXdlc3QtMiJHMEUCIQDW%2F5%2FnoOeukz0UcnMKXzGOn4TvHn9svu0xH5gztVvFPwIgdjkFBYCipObemsMLhyjlxDkvBs8ds%2FdzDN0rj0qrBKkq%2FwMIOxAAGgw2Mzc0MjMxODM4MDUiDGQaVUspFQ7jxM2npCrcA%2BNVf0DJAPKCDYKd3B78SroldzCX%2FgLipXn6wEXM9p8CXnDgWvc4Stf9m3LoxZJVLqny8eXWjMKpM9HBkG3QgBXcV3quaD2zu11N2nPJ2Z%2Bdkg7uBbm3Jt0eCeoFMbywPONOTx8ZDwPjXwtBeaQhKuFnTJ%2Fn6F%2BVtmw3xO4KxqzRzcPNUlcuGvITT%2FfW0L8HBicUgJfeKDKQm7%2BW9DXZHeAej%2BJae946LmeasgmKwtKVwUAMU0ZRIRRRNBXFxUiBDyz96e4QvfK4IjhEs0SQQCae2y1hUvnJqNXXMPTysoCnoUxJtfIzeYsGlGZgtCDJBc1sOwikWM%2FDW5BT2LzPY9XQzoqoGwrHDEWMr4JehB10bkX6%2BjdHvrwlOk8EwoUMjbY4RtuV008QgrmSnOrEmku4F7GTRJ39kw%2FQ%2FxBwPglCkcMU%2FFq%2FbC1hBPxZiHVFcVWznIjDeF04KEX713IxCdsESiubJ9zBjcIGyeie2mR%2BcMXlYbHDAzh6FLADqI%2FErkNgtEo4ISsYzBYB8fJxfkY9dRhNwQ9zw9vlxHxP3M3iz18xaTamH3Q4UjLYzanCsoJt8i8tF1thjulyuNtUzeIYoWT7LN0mxAR3hpE4q6PFM5Oaci8JAa6%2BhYbXMIv73MsGOqUBHNpAjAyR7mkDWQ0bkpYoxpR9khY4rNf5yRVfB%2BvgapZONnjYqk5ch%2Ft%2FQxE4wFN0wFmzNMN3nKTo1fNjb1gHmfODoehFCXa13k%2Fe4J7drgLDOfkBpC68vfx6xdMk8njBNQ8MnH55LEyJxbfH1hlTGA1Ymvcza08m5guYh3rh%2BDEXJEX0JQVaKYa9BSZEsp3eEnInof8rstkrzp9DHceu97laoxKb&X-Amz-Signature=c06d679cd40f27a9f1e42143110919a1ae63e9f0e5d3494e0699b6889a453056&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


> 💡 **unique 속성을 잘 사용하지 않는 이유**❓  
> `unique = true` 로 생성하면 이름이 랜덤하게 생성돼서 나중에 에러 발생 시 알아보기 어려움  
>   
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/51e764a1-fa53-482b-9289-8936c57340cf/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4664Q5DXRXS%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T105446Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHIaCXVzLXdlc3QtMiJHMEUCIE%2FY8Lu2YK%2BmPMsBN1u5ETTJo8BwKF39utUAQrdWaciXAiEAwehgw6T4rUpvjUwCx%2BU92UZ0%2FI9QrvqDRDBWEVm1RbEq%2FwMIOxAAGgw2Mzc0MjMxODM4MDUiDKpZrOueuq4QUtG15yrcA4%2FwKb6a7K7VLj7OTypJ%2F9pFRLdbtuqL3xhwXxzsO9DA8uObbtD1Xrt2XQYaxJYWZ0FfW22qbfsOqLgNqAvLKc%2FCMHiwpPqxNqj4aZaRKN9YXTAQZku3UkfZ4ke8G2rYXllGkgpq4Xy7WKtJccS0VxYRor7YtWH6LEWONFZFrVAH8%2FsVzwy1vcZkOLfL5uL1iV1%2FrvlhMNv3PuhoIO9xSZyG%2BjilNnT5WwGUnpm2LG0QkAg9it2RFc%2FWGU5voNv9NWqtMGjTwD7wOViSADYZefIa6YpnUUqcmHOvA1RyPXvrnAzxG2x8nKyP%2BTIgqms60iUsUoirbH7bbf41Rs5PQLSqqylcjYPqDqFX9NH%2BO09or0a3WTS1z8H%2FnxU1GuBgI0x856LXQXchQqzthtaifC9Sk1SciRxvXOKLgync3TGYdL6VeXRSyKB0vLDR%2BQl5KjoqvtKu2ilF%2FVlf7mk%2FSixAE7iYS1dEA3kgbJbWj0sfwM7KOf12oXhPakn89eNFDOED5xOkJN0OvIHeNma7C43qAD8vG7XCNdMWl4nNzxjBYY5xEauLi0I9UkY%2B1O%2BT%2BvAwfnPb01mMHSL7FHTxUIWH4R47Q%2BGpvnFxPdnyz4NHRizeuMp%2BqB4yLyLSMMz63MsGOqUB%2Fv4wdjQQzjcEebECr8QX6tF9JZxJfG9UkIAaUYIC52bLuaftwzaYoGlWKK%2BZnB9BcDNxAcsHXo0Xv9OqQn%2F2%2Ft2Hl3p0z5eeGEm0bH7sEJWOTjfwWluIo%2FbpRq8Ua98eCWEwh4buO7CVGIeQ1UZwbE7yMZhCZe380qzyFXrM7T17F8ScfRL5n%2BFeq9O%2F6GzGC6hFsSoozVH9Vj7w1gSsaTP%2FXP6j&X-Amz-Signature=d6750ac3191c8660b823fe40112f7b27bc49b676af8dc5e25287f6f80f9cc1c2&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)  
>   
> 그래서 테이블 어노테이션에서 유니크 제약조건 이름을 직접 설정하는 방법을 사용함  
>   
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/3c6aff65-21c4-4bc6-bb9d-9e278a10971c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4664Q5DXRXS%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T105446Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHIaCXVzLXdlc3QtMiJHMEUCIE%2FY8Lu2YK%2BmPMsBN1u5ETTJo8BwKF39utUAQrdWaciXAiEAwehgw6T4rUpvjUwCx%2BU92UZ0%2FI9QrvqDRDBWEVm1RbEq%2FwMIOxAAGgw2Mzc0MjMxODM4MDUiDKpZrOueuq4QUtG15yrcA4%2FwKb6a7K7VLj7OTypJ%2F9pFRLdbtuqL3xhwXxzsO9DA8uObbtD1Xrt2XQYaxJYWZ0FfW22qbfsOqLgNqAvLKc%2FCMHiwpPqxNqj4aZaRKN9YXTAQZku3UkfZ4ke8G2rYXllGkgpq4Xy7WKtJccS0VxYRor7YtWH6LEWONFZFrVAH8%2FsVzwy1vcZkOLfL5uL1iV1%2FrvlhMNv3PuhoIO9xSZyG%2BjilNnT5WwGUnpm2LG0QkAg9it2RFc%2FWGU5voNv9NWqtMGjTwD7wOViSADYZefIa6YpnUUqcmHOvA1RyPXvrnAzxG2x8nKyP%2BTIgqms60iUsUoirbH7bbf41Rs5PQLSqqylcjYPqDqFX9NH%2BO09or0a3WTS1z8H%2FnxU1GuBgI0x856LXQXchQqzthtaifC9Sk1SciRxvXOKLgync3TGYdL6VeXRSyKB0vLDR%2BQl5KjoqvtKu2ilF%2FVlf7mk%2FSixAE7iYS1dEA3kgbJbWj0sfwM7KOf12oXhPakn89eNFDOED5xOkJN0OvIHeNma7C43qAD8vG7XCNdMWl4nNzxjBYY5xEauLi0I9UkY%2B1O%2BT%2BvAwfnPb01mMHSL7FHTxUIWH4R47Q%2BGpvnFxPdnyz4NHRizeuMp%2BqB4yLyLSMMz63MsGOqUB%2Fv4wdjQQzjcEebECr8QX6tF9JZxJfG9UkIAaUYIC52bLuaftwzaYoGlWKK%2BZnB9BcDNxAcsHXo0Xv9OqQn%2F2%2Ft2Hl3p0z5eeGEm0bH7sEJWOTjfwWluIo%2FbpRq8Ua98eCWEwh4buO7CVGIeQ1UZwbE7yMZhCZe380qzyFXrM7T17F8ScfRL5n%2BFeq9O%2F6GzGC6hFsSoozVH9Vj7w1gSsaTP%2FXP6j&X-Amz-Signature=9230b12ccc0a1ad6290eedf5b1437223070b3ea52b770d13316f41501ca5e6d9&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


Enumerated  는 type 을 Ordinal과 String중에 선택할 수 있는데 무조건 String 사용해야 함


lob은 지정할 수 있는 속성이 없음 문자면 clob 아니면 blob 자동으로


### 기본키 매핑


@Id


직접 할당


@GeneratedValue


자동 생성 (sequence, …)

1. strategy - GenerationType.IDENTITY
db가 알아서 해줌, 시퀀스같은
예외적으로 커밋하는 시점에 쿼리 날리는게 아니라 em.persist 실행했을 때 바로 디비에 insert 쿼리 날림
⇒ 모아서 insert 불가하다는게 단점, 성능에는 크게 차이 없
2. strategy - GenerationType.SEQUENCE
시퀀스는 long을 쓰는게 정석
이렇게 하면 자동으로 생성되는데 @SequenceGenerator 를 써서 이름 지정 가능
얘도 db에 가봐야 값을 알 수 있음
em.persistence 할 때 시퀀스 값을 조회 > 영속성 컨텍스트에 저장 > 커밋 전까지 디비에는 값 저장 X
⇒ 버퍼링 가능
    1. @SequenceGenerator
    name 지정하고 컬럼에서 generator 에 그 name 넣으면 됨
    allocationSize : 50 설정하면 한 번 실행했을 때 50개까지 미리 만들어두고 그 다음부터는 메모리에 있는 값으로 가져옴 성능

@TableGenerator
솔직히 잘 쓰진 않음 시퀀스 생성용 테이블, 시퀀스 이름이랑 값이 있음


**권장하는 식별자 전략**


long 형 + 대체키(UUID) 키 생성전략 사용 ( 자연키 ex. 주민등록번호 도 적절하지 않을 수 있다)


### 연관관계


객체를 테이블에 딱 맞춰서 모델링 하면 (ex. 외래키 등 이용해서) 객체지향스럽지 않고 관계형디비스러움, 객체는 참조를 사용하기 때문에

- 단방향 연관관계
    - 한쪽으로만 참조
- 양방향 연관관계
    - 양쪽으로 참조
    - 연관관계 주인 : 양쪽 중에서 하나를 주인으로 설정하고 걔만 외래키를 관리(등록, 수정), mapped by는 주인이 아닐 때 지정, 외래키가 있는 곳을 주인으로 지정해야함(DB 테이블 n 쪽인 곳)
    - 값은 연관관계의 주인에 넣어야 함 안그러면 외래키 값이 null로 들어감
    - 근데 사실 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는게 좋음
        - 양쪽에 설정하지 않았을 경우에는 commit 전에 조회할 경우 영속성 컨텍스트때문에 select 쿼리가 나가지 않고 캐시에서 조회하기 때문에 값이 있는데 없다고 나올 수 있음
    - 컨트롤러에서는 엔티티를 반환하면 안됨 (dto로 변환해서 반환하기)
        - 무한루프 생길 수 있음 (toString, lombok, …
        - 엔티티 변경하는 순간 api 스펙이 변경됨
    - 단방향 매핑으로 다 끝낸다는 생각으로 하기 그리고 꼭 필요할 때 양방향 매핑 추가

### 다양한 연관관계 매핑

- 다대일
    - 다 인 쪽에 외래키가 있음 > 얘가 연관관계 주인
    - 다 인 쪽에 @ManytoOne @JoinColumn(name=””)
    - 1 인 쪽에 @OnetoMany(mappedBy=””)
- 일대다
    - 일단 권장 안함
    - 1인 쪽이 주인
    - 일대 다일 때 양방향 하고싶으면 다인 쪽에 insertable false, updatable false 넣으면 됨
- 일대일
    - 다대일 단방향과 비슷, 어노테이션만 다름
    - 내 엔티티의 외래키는 내가 직접 관리해야 함
- 다대다
    - 실무에서 쓰면 안됨
    - 연결 테이블을 생성해서 사용함
    - 다대일로 변경해서 사용해야함 (연결 테이블을 엔티티로 승격해서 사용해야 함)
