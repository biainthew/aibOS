---
layout: post
title: "Jpa"
date: 2025-07-17
categories: [general]
tags: [Sql]
excerpt_separator: ""
---



{% raw %}
```shell
set JAVA_HOME=C:\dev\jdk-17.0.2
set PATH=%JAVA_HOME%\bin;%PATH%
```
{% endraw %}


### JPA 왜 쓰냐?


안 쓰면 자바 객체를 SQL로 변환, SQL을 자바 객체로 변환 -> 이 과정을 계속 반복해야 함


### 메모


객체는 참조로 연관관계를 맺는다


**ORM** : 객체와 관계형 DB를 매핑


### JPQL 왜 쓰냐 ?


JPA를 사용하면 엔티티 객체를 중심으로 개발하게 되는데 검색 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색함


=> 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능


=> 어플리케이션이 필요한 데이터만 불러오려면 검색 조건이 포함된 SQL이 필요


### 영속성 컨텍스트


엔티티를 영구 저장하는 환경


`EntityManager.persist(entity);`


=> 저장이 되는게 아니라 사실 영속성 컨텍스트가 생성됨 그리고 저장은 커밋하는 시점에 됨


이점 ?


캐싱 가능 => DB에서 조회하지 않고 1차 캐시에서 조회 가능


영속 엔티티의 동일성 보장


~ 섹션 4


### 엔티티 매핑


_`<property name="hibernate.hbm2ddl.auto" value="create" />`_


: 데이터베이스 스키마 자동 생성


- 개발 초기 단계는 create, update


- 테스트 서버는 update, validate : 사실 update도 안 쓰는게 좋긴 함


- 운영 서버는 validate, none


![image.png](/aibOS/public/images/posts/28e0a7f9-83c1679e631e.png)


> 💡 **unique 속성을 잘 사용하지 않는 이유**❓  
> `unique = true` 로 생성하면 이름이 랜덤하게 생성돼서 나중에 에러 발생 시 알아보기 어려움  
>   
> ![image.png](/aibOS/public/images/posts/28e0a7f9-b0ad45ddcce2.png)  
>   
> 그래서 테이블 어노테이션에서 유니크 제약조건 이름을 직접 설정하는 방법을 사용함  
>   
> ![image.png](/aibOS/public/images/posts/28e0a7f9-fa1b61007163.png)


Enumerated  는 type 을 Ordinal과 String중에 선택할 수 있는데 무조건 String 사용해야 함


lob은 지정할 수 있는 속성이 없음 문자면 clob 아니면 blob 자동으로


### 기본키 매핑


@Id


직접 할당


@GeneratedValue


자동 생성 (sequence, …)

1. strategy - GenerationType.IDENTITY
db가 알아서 해줌, 시퀀스같은
예외적으로 커밋하는 시점에 쿼리 날리는게 아니라 em.persist 실행했을 때 바로 디비에 insert 쿼리 날림
⇒ 모아서 insert 불가하다는게 단점, 성능에는 크게 차이 없
2. strategy - GenerationType.SEQUENCE
시퀀스는 long을 쓰는게 정석
이렇게 하면 자동으로 생성되는데 @SequenceGenerator 를 써서 이름 지정 가능
얘도 db에 가봐야 값을 알 수 있음
em.persistence 할 때 시퀀스 값을 조회 > 영속성 컨텍스트에 저장 > 커밋 전까지 디비에는 값 저장 X
⇒ 버퍼링 가능
    1. @SequenceGenerator
    name 지정하고 컬럼에서 generator 에 그 name 넣으면 됨
    allocationSize : 50 설정하면 한 번 실행했을 때 50개까지 미리 만들어두고 그 다음부터는 메모리에 있는 값으로 가져옴 성능

@TableGenerator
솔직히 잘 쓰진 않음 시퀀스 생성용 테이블, 시퀀스 이름이랑 값이 있음


**권장하는 식별자 전략**


long 형 + 대체키(UUID) 키 생성전략 사용 ( 자연키 ex. 주민등록번호 도 적절하지 않을 수 있다)


### 연관관계


객체를 테이블에 딱 맞춰서 모델링 하면 (ex. 외래키 등 이용해서) 객체지향스럽지 않고 관계형디비스러움, 객체는 참조를 사용하기 때문에

- 단방향 연관관계
    - 한쪽으로만 참조
- 양방향 연관관계
    - 양쪽으로 참조
    - 연관관계 주인 : 양쪽 중에서 하나를 주인으로 설정하고 걔만 외래키를 관리(등록, 수정), mapped by는 주인이 아닐 때 지정, 외래키가 있는 곳을 주인으로 지정해야함(DB 테이블 n 쪽인 곳)
    - 값은 연관관계의 주인에 넣어야 함 안그러면 외래키 값이 null로 들어감
    - 근데 사실 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는게 좋음
        - 양쪽에 설정하지 않았을 경우에는 commit 전에 조회할 경우 영속성 컨텍스트때문에 select 쿼리가 나가지 않고 캐시에서 조회하기 때문에 값이 있는데 없다고 나올 수 있음
    - 컨트롤러에서는 엔티티를 반환하면 안됨 (dto로 변환해서 반환하기)
        - 무한루프 생길 수 있음 (toString, lombok, …
        - 엔티티 변경하는 순간 api 스펙이 변경됨
    - 단방향 매핑으로 다 끝낸다는 생각으로 하기 그리고 꼭 필요할 때 양방향 매핑 추가

### 다양한 연관관계 매핑

- 다대일
    - 다 인 쪽에 외래키가 있음 > 얘가 연관관계 주인
    - 다 인 쪽에 @ManytoOne @JoinColumn(name=””)
    - 1 인 쪽에 @OnetoMany(mappedBy=””)
- 일대다
    - 일단 권장 안함
    - 1인 쪽이 주인
    - 일대 다일 때 양방향 하고싶으면 다인 쪽에 insertable false, updatable false 넣으면 됨
- 일대일
    - 다대일 단방향과 비슷, 어노테이션만 다름
    - 내 엔티티의 외래키는 내가 직접 관리해야 함
- 다대다
    - 실무에서 쓰면 안됨
    - 연결 테이블을 생성해서 사용함
    - 다대일로 변경해서 사용해야함 (연결 테이블을 엔티티로 승격해서 사용해야 함)
