---
layout: post
title: "Jpa"
date: 2025-07-17
categories: [general]
tags: [Sql]
---


```shell
set JAVA_HOME=C:\dev\jdk-17.0.2
set PATH=%JAVA_HOME%\bin;%PATH%
```


### JPA 왜 쓰냐?


안 쓰면 자바 객체를 SQL로 변환, SQL을 자바 객체로 변환 -> 이 과정을 계속 반복해야 함


### 메모


객체는 참조로 연관관계를 맺는다


**ORM** : 객체와 관계형 DB를 매핑


### JPQL 왜 쓰냐 ?


JPA를 사용하면 엔티티 객체를 중심으로 개발하게 되는데 검색 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색함


=> 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능


=> 어플리케이션이 필요한 데이터만 불러오려면 검색 조건이 포함된 SQL이 필요


### 영속성 컨텍스트


엔티티를 영구 저장하는 환경


`EntityManager.persist(entity);`


=> 저장이 되는게 아니라 사실 영속성 컨텍스트가 생성됨 그리고 저장은 커밋하는 시점에 됨


이점 ?


캐싱 가능 => DB에서 조회하지 않고 1차 캐시에서 조회 가능


영속 엔티티의 동일성 보장


~ 섹션 4


### 엔티티 매핑


_`<property name="hibernate.hbm2ddl.auto" value="create" />`_


: 데이터베이스 스키마 자동 생성


- 개발 초기 단계는 create, update


- 테스트 서버는 update, validate : 사실 update도 안 쓰는게 좋긴 함


- 운영 서버는 validate, none


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/d1635e83-02bd-42e7-a238-520ed8924cc4/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662MCYRCZC%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T094731Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHEaCXVzLXdlc3QtMiJIMEYCIQD6U%2FiZRM8r0yRb7BXWXPauwoN%2BBU35TxryKLJPGHqqUwIhAPmK0VeujBMdjcG%2FT3405NRpHPaZaVaEYaA9N9ISYXYAKv8DCDoQABoMNjM3NDIzMTgzODA1IgzS5sLQ6rsT1UiwQP8q3AP0Pmp3BhE9mszG3pyXlPDwc5abHrPwqraWPOA3W%2FCa3%2Bxr1gblyxUyr7XH2BFfDZya1PYxe8aSmiPnAUY3PQIMYqHzUr69K3v8sG%2FuD14mMgzttax7Qmu2g0p6U7scdT%2Fg%2FPLJgNJ5JvskqfAEMphuU%2BsCf%2FukVBXrI5nyV9KVNJ6K3FdJTZa2UiE6mt386SwWakohnlc%2FQWrvN4a%2BPWpyFB%2BZCVTyM3JKtgoXAS4PnHQGTO4aj6D8Otpg0zOZ9%2BCEYaaaWQntzOY2H1LJCZH12R3sO0kFtICVAkY%2FXmFUs84kYwooAVZwWL7O%2FBsKaA9Fm4jDbk0xoLsn4j%2BxLdayEzl6zC3IGlQe8YxSyq3X3TK3HCpEeZ6lt5mMbHJbj9yqMaoiID%2FBhiakDe%2FFPAfEvC1D7nGqvno5GI4r8WGDs4ceRixULr2ZdlnSrIJPNycGw7i6319CZkBQz0GQn8QwFr2deilzJ7yd9XTLVnQZxYGKCOSpPhqNFWf8L0%2BCVzKrEVGj6agmcLP8jM7sLW1XUWzWE2emWQwU%2FDqWCI%2Fv4kKQuXQjSH%2Bg4XMWT5BZMNEUQw71%2BIX8PdW1A3PnuyF1YQ8F8n4oukz5esZYDtIAiN3PBFI0VcjMaPlc8DCp2dzLBjqkAYZVMEoZ6ykddMj8Pwaaxif5UKoTLHS0vSTQIjWb6M8%2Fk%2BTtx5tKIVaFNZQiOeR4iqh%2FWmkFmm%2BeChK1q6SHb0Lr8utD%2FVrFx8u0pKRqGmT5CyRjExeEoWUcd4TpcEnvA3g8Ox3MixD7R3zdXBHTMFa29S%2F0d4TK7vTcCngzPTJKwxl7vfb3FF1p5jbuiJ93vfLTuheOKjRztefpg1uJBFsT3O1r&X-Amz-Signature=12e1057bfe1adf36965f53a126be9f3a91aedbbca73873b15c946d4e75f300ad&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


> 💡 **unique 속성을 잘 사용하지 않는 이유**❓  
> `unique = true` 로 생성하면 이름이 랜덤하게 생성돼서 나중에 에러 발생 시 알아보기 어려움  
>   
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/51e764a1-fa53-482b-9289-8936c57340cf/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4665WFGQMSO%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T094731Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHEaCXVzLXdlc3QtMiJIMEYCIQCvL3zNO3s0%2Bn49LjyYDHv4EEOkCXJf2OUs5gnsADutJQIhAOXWGk1YLcDHUTKDBQZz%2Bo6dQJbTNNCxb0vHJ7yj2Cy8Kv8DCDoQABoMNjM3NDIzMTgzODA1Igyny6j3XYfGIxEUYHkq3AMZqppZxTy7ExvPjo7iQh74KnXhpT15%2F1ILE0naRQ2qb4tb2JMcOuwif6z8pKq2MmuAd4LYe%2Bfe4ZUto1vWD6T8MRyiSXOb5fMKY6%2Bp8%2F7a0tLzqQXrJYKm5GGUApzpWrS11I%2FzFHyjUqUpO8xGQWVyI5G9CaOyNpxDHtQvHEFAM1S7XXh6hPXGYmHZPZnmWexNwmzRu6px5DyGm1fU8ChBHSUFcSNs7HMzgE9yHaX%2F4CSwY9w55IuY%2FvMSCNV5qecZl8A9QJxfKr8lhtrsqPjPTIup5YgKo9L40UXl19o0T8Bd%2FWyZqAv9ygD5DXPTZS3YwfW8w1cE%2BqFzrLupf9L7wNuIep15%2B0tAAN1bUdDvBMb%2ByiTTBMohAZT3Ak0OIVMifKEodk%2BPesSm%2F1MsfrvHkwgiGMTkGSrf3Q62cselpIScHVyd04GVBPjl%2FfMPY3hllN9cKkAI4C7mD79kdg8UXJXmlRz%2FKtuzVC%2F6txWxn5pcWhNH3K%2B7wv4aw7RmH18AkMSYIugY7%2Fn87M%2FYjvI2WBlwsQJPyCIqA4O%2BGQX%2BFlHZuIkTw38Oob%2FTO5GbWPmfvLBQr99Nz94Zudx%2FNlMzMcF9szRg60zbSt58pxLKyFCMPqKVlw52wmIm4jC%2B2NzLBjqkARGHr%2FsJ62%2F64mtq1Nnrk%2F1JqaRa1uqzY035%2BxuwkIGangcbz5eG5ctqeOV3IkkIVxqtnzzJ4IEpctB%2FMA1u0nbSxfj5GNaNo0fnV4nuEooI%2FTBE73SF0Uq8cdWR9N0GGjUnPzDb27VN8qDsR0Pwr4%2FzBd0ioGXBzXz8C7Pg7QpYRmSfB%2FAaKEZK76kA54u6yj%2Fzi62UqZRseI5NLZoX%2BT54jveX&X-Amz-Signature=de9eafe4e6f62ec1e106d0761bcf4ad6292d661a3f9e5f11b37ff2a002ab0629&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)  
>   
> 그래서 테이블 어노테이션에서 유니크 제약조건 이름을 직접 설정하는 방법을 사용함  
>   
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8fe0a7f9-120c-81d3-b4d8-0003f7c0f162/3c6aff65-21c4-4bc6-bb9d-9e278a10971c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4665WFGQMSO%2F20260126%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260126T094731Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHEaCXVzLXdlc3QtMiJIMEYCIQCvL3zNO3s0%2Bn49LjyYDHv4EEOkCXJf2OUs5gnsADutJQIhAOXWGk1YLcDHUTKDBQZz%2Bo6dQJbTNNCxb0vHJ7yj2Cy8Kv8DCDoQABoMNjM3NDIzMTgzODA1Igyny6j3XYfGIxEUYHkq3AMZqppZxTy7ExvPjo7iQh74KnXhpT15%2F1ILE0naRQ2qb4tb2JMcOuwif6z8pKq2MmuAd4LYe%2Bfe4ZUto1vWD6T8MRyiSXOb5fMKY6%2Bp8%2F7a0tLzqQXrJYKm5GGUApzpWrS11I%2FzFHyjUqUpO8xGQWVyI5G9CaOyNpxDHtQvHEFAM1S7XXh6hPXGYmHZPZnmWexNwmzRu6px5DyGm1fU8ChBHSUFcSNs7HMzgE9yHaX%2F4CSwY9w55IuY%2FvMSCNV5qecZl8A9QJxfKr8lhtrsqPjPTIup5YgKo9L40UXl19o0T8Bd%2FWyZqAv9ygD5DXPTZS3YwfW8w1cE%2BqFzrLupf9L7wNuIep15%2B0tAAN1bUdDvBMb%2ByiTTBMohAZT3Ak0OIVMifKEodk%2BPesSm%2F1MsfrvHkwgiGMTkGSrf3Q62cselpIScHVyd04GVBPjl%2FfMPY3hllN9cKkAI4C7mD79kdg8UXJXmlRz%2FKtuzVC%2F6txWxn5pcWhNH3K%2B7wv4aw7RmH18AkMSYIugY7%2Fn87M%2FYjvI2WBlwsQJPyCIqA4O%2BGQX%2BFlHZuIkTw38Oob%2FTO5GbWPmfvLBQr99Nz94Zudx%2FNlMzMcF9szRg60zbSt58pxLKyFCMPqKVlw52wmIm4jC%2B2NzLBjqkARGHr%2FsJ62%2F64mtq1Nnrk%2F1JqaRa1uqzY035%2BxuwkIGangcbz5eG5ctqeOV3IkkIVxqtnzzJ4IEpctB%2FMA1u0nbSxfj5GNaNo0fnV4nuEooI%2FTBE73SF0Uq8cdWR9N0GGjUnPzDb27VN8qDsR0Pwr4%2FzBd0ioGXBzXz8C7Pg7QpYRmSfB%2FAaKEZK76kA54u6yj%2Fzi62UqZRseI5NLZoX%2BT54jveX&X-Amz-Signature=3e77f29f347053b0aa2ce4554f58cdffd89c012d9f99a92ad28043115bb47750&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


Enumerated  는 type 을 Ordinal과 String중에 선택할 수 있는데 무조건 String 사용해야 함


lob은 지정할 수 있는 속성이 없음 문자면 clob 아니면 blob 자동으로


### 기본키 매핑


@Id


직접 할당


@GeneratedValue


자동 생성 (sequence, …)

1. strategy - GenerationType.IDENTITY
db가 알아서 해줌, 시퀀스같은
예외적으로 커밋하는 시점에 쿼리 날리는게 아니라 em.persist 실행했을 때 바로 디비에 insert 쿼리 날림
⇒ 모아서 insert 불가하다는게 단점, 성능에는 크게 차이 없
2. strategy - GenerationType.SEQUENCE
시퀀스는 long을 쓰는게 정석
이렇게 하면 자동으로 생성되는데 @SequenceGenerator 를 써서 이름 지정 가능
얘도 db에 가봐야 값을 알 수 있음
em.persistence 할 때 시퀀스 값을 조회 > 영속성 컨텍스트에 저장 > 커밋 전까지 디비에는 값 저장 X
⇒ 버퍼링 가능
    1. @SequenceGenerator
    name 지정하고 컬럼에서 generator 에 그 name 넣으면 됨
    allocationSize : 50 설정하면 한 번 실행했을 때 50개까지 미리 만들어두고 그 다음부터는 메모리에 있는 값으로 가져옴 성능

@TableGenerator
솔직히 잘 쓰진 않음 시퀀스 생성용 테이블, 시퀀스 이름이랑 값이 있음


**권장하는 식별자 전략**


long 형 + 대체키(UUID) 키 생성전략 사용 ( 자연키 ex. 주민등록번호 도 적절하지 않을 수 있다)


### 연관관계


객체를 테이블에 딱 맞춰서 모델링 하면 (ex. 외래키 등 이용해서) 객체지향스럽지 않고 관계형디비스러움, 객체는 참조를 사용하기 때문에

- 단방향 연관관계
    - 한쪽으로만 참조
- 양방향 연관관계
    - 양쪽으로 참조
    - 연관관계 주인 : 양쪽 중에서 하나를 주인으로 설정하고 걔만 외래키를 관리(등록, 수정), mapped by는 주인이 아닐 때 지정, 외래키가 있는 곳을 주인으로 지정해야함(DB 테이블 n 쪽인 곳)
    - 값은 연관관계의 주인에 넣어야 함 안그러면 외래키 값이 null로 들어감
    - 근데 사실 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는게 좋음
        - 양쪽에 설정하지 않았을 경우에는 commit 전에 조회할 경우 영속성 컨텍스트때문에 select 쿼리가 나가지 않고 캐시에서 조회하기 때문에 값이 있는데 없다고 나올 수 있음
    - 컨트롤러에서는 엔티티를 반환하면 안됨 (dto로 변환해서 반환하기)
        - 무한루프 생길 수 있음 (toString, lombok, …
        - 엔티티 변경하는 순간 api 스펙이 변경됨
    - 단방향 매핑으로 다 끝낸다는 생각으로 하기 그리고 꼭 필요할 때 양방향 매핑 추가

### 다양한 연관관계 매핑

- 다대일
    - 다 인 쪽에 외래키가 있음 > 얘가 연관관계 주인
    - 다 인 쪽에 @ManytoOne @JoinColumn(name=””)
    - 1 인 쪽에 @OnetoMany(mappedBy=””)
- 일대다
    - 일단 권장 안함
    - 1인 쪽이 주인
    - 일대 다일 때 양방향 하고싶으면 다인 쪽에 insertable false, updatable false 넣으면 됨
- 일대일
    - 다대일 단방향과 비슷, 어노테이션만 다름
    - 내 엔티티의 외래키는 내가 직접 관리해야 함
- 다대다
    - 실무에서 쓰면 안됨
    - 연결 테이블을 생성해서 사용함
    - 다대일로 변경해서 사용해야함 (연결 테이블을 엔티티로 승격해서 사용해야 함)
