---
layout: post
title: "추상 클래스, 인터페이스"
date: 2025-02-13
categories: [general]
tags: [Java]
excerpt_separator: ""
---



### 개념

- 추상 클래스와 비슷하지만 더 강한 강제성을 가진 추상적인 설계도
- 모든 메서드는 기본적으로 추상메서드임(구현 X, 선언만 존재)
- 다중 상속을 지원 (클래스는 하나만 상속 가능하지만 인터페이스는 여러 개 구현 가능)
- `interface` 키워드를 사용

### 예시


{% raw %}
```java
// 1. 인터페이스 선언 (모든 메서드는 구현 없이 선언만 존재)
interface Animal {
	void makeSound(); // 추상 메서드 (구현 X)
}

// 2. Dog 클래스가 Animal 인터페이스를 구현 (implements)
class Dog implements Animal {
	@Override
	public void makeSound() {
		System.out.println("Woof! Woof!");
	}
}

// 3. Main 실행 코드
public class InterfaceExample {
	public static void main(String[] args) {
		Dog myDog = new Dog();
		myDog.makeSound(); // 실행
	}
}

// 실행 결과 : Woof! Woof!
```
{% endraw %}


### 인터페이스 vs 추상 클래스


| **구분** | **추상 클래스**                        | **인터페이스**                         |
| ------ | --------------------------------- | --------------------------------- |
| 키워드    | `abstract class`                  | `interface`                       |
| 객체 생성  | 불가능                               | 불가능                               |
| 필드(변수) | 선언 가능 (`protected`, `private` 가능) | 모든 변수는 `public static final` (상수) |
| 메서드    | 일반 메서드 + 추상 메서드 혼용 가능             | 모든 메서드는 기본적으로 추상 메서드              |
| 다중 상속  | 불가능 (`extends` 하나만 가능)            | 가능 (`implements` 여러 개 가능)         |


### 다중 구현


{% raw %}
```java
// 1. 인터페이스 두 개 선언
interface Animal {
	void makeSound();
}

interface Pet {
	void play();
}

// 2. Dog 클래스가 두 개의 인터페이스를 구현
class Dog implements Animal, Pet {
	@Override
	public void makeSound() {
		System.out.println("Woof!");
	}
	
	@Override
	public void play() {
		System.out.println("Playing fetch!");
	}
}

// 3. Main 실행 코드
public class MultipleInterfaceExample {
	public static void main(String[] args) {
		Dog myDog = new Dog();
		myDog.makeSound();
		myDog.play();
	}
}

// 실행 결과 : Woof! /n Playing fetch!
```
{% endraw %}

- Dog 클래스는 Animal 과 Pet 두 개의 인터페이스를 동시에 구현할 수 있음
- 하나의 클래스가 여러가지 역할을 할 수 있으므로 유지보수 및 확장성이 좋아짐

### 왜 쓰냐 ?


인터페이스와 추상 클래스는 객체지향 프로그래밍의 핵심 개념인 추상화를 실현하기 위한 도구로


코드를 더 유연하고 확장 가능하게 만들기 위해서 사용

1. 코드 재사용성과 유지보수 향상
    - 같은 기능을 여러 개의 클래스에서 사용할 때 중복 코드를 줄일 수 있음
    - 기능이 변경되면 한 곳만 수정하면 되므로 유지보수가 쉬워짐
2. 강제적인 구현 규칙 제공
    - 특정 기능이 반드시 필요할 때 이를 강제할 수 있음
    - 추상 클래스나 인터페이스가 없으면 개발자가 메서드를 깜빡하고 안 만들 수도 있음
3. 유연한 설계 (다형성 활용)
    - 부모 타입(추상 클래스나 인터페이스)으로 다양한 객체를 다룰 수 있음
    - 새로운 기능 추가 시 기존 코드를 수정할 필요 없이 확장 가능

|          | **추상 클래스**                       | **인터페이스**                                 |
| -------- | -------------------------------- | ----------------------------------------- |
| 사용 목적    | 공통된 기능 제공 (재사용성)                 | 특정 기능을 강제 (설계도 역할)                        |
| 메서드 구현   | 일부 구현 가능 (일반 메서드 O)              | 모든 메서드 기본적으로 추상 메서드 (JDK 8 이상부터 일부 구현 가능) |
| 다중 상속    | X (하나만 상속 가능)                    | O (여러 개 구현 가능)                            |
| 필드       | 일반 변수, 상수 모두 가능                  | 무조건 public static final (상수만 가능)          |
| 대표 사용 사례 | `Animal`, `Vehicle` 같은 공통 속성 클래스 | `Runnable`, `Comparable` 같은 역할 지정         |


### 결론


공통된 기능을 포함하고 일부만 강제하고 싶다면 **추상 클래스**


모든 메서드가 특정 규칙을 따라야 하고 다중 구현이 필요하다면 **인터페이스**


JDK 8 이후에는 인터페이스에서도 default 메서드를 지원하므로 유연성이 더 증가됨


### 테스트

1. 

{% raw %}
```java
abstract class Shape {
    abstract double area();
}

// 여기에 Circle, Rectangle 클래스를 완성하세요!
class Circle {
	public static area(int radius) {
		String result = 3.14 * radius * radius
		System.out.println(result);
	}
}

class Rectangle {
	public static area(int width, int height) {
		String result = width * height;
		System.out.println(result)
	}
}

public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle(5);  // 반지름 5
        Shape rectangle = new Rectangle(4, 6);  // 가로 4, 세로 6

        System.out.println("원 면적: " + circle.area());  // 78.54 (대략적인 값)
        System.out.println("직사각형 면적: " + rectangle.area());  // 24
    }
}
```
{% endraw %}


{% raw %}
```java
abstract class Shape {
    abstract double area();
}

// 여기에 Circle, Rectangle 클래스를 완성하세요!
class Circle extends Shape {
	private double radius;
	
	public Circle(double radius) {
		this.radius = radius;
	}
	
	@Override
	double area() {
		return 3.14 * radius * radius;
	}
}

class Retangle extends Shape {
	private double width, height;
	
	public Retangle(double width, double height) {
		this.width = width;
		this.height = height;
	}
	
	@Override
	double area() {
		return width * height;
	}
}

public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle(5);  // 반지름 5
        Shape rectangle = new Rectangle(4, 6);  // 가로 4, 세로 6

        System.out.println("원 면적: " + circle.area());  // 78.54 (대략적인 값)
        System.out.println("직사각형 면적: " + rectangle.area());  // 24
    }
}
```
{% endraw %}

1. 

{% raw %}
```java
interface Playable {
    // 여기에 추상 메서드 선언하기
    
}

// 여기에 Guitar, Piano 클래스를 완성하세요!

public class Main {
    public static void main(String[] args) {
        Playable guitar = new Guitar();
        Playable piano = new Piano();

        guitar.playSound();  // Strumming guitar!
        piano.playSound();   // Playing piano!
    }
}
```
{% endraw %}

