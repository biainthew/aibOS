---
layout: post
title: "postJson"
date: 2025-01-03
categories: [general]
tags: [Javascript/Jquery]
excerpt_separator: ""
---



```javascript
$component.postJson = function($outline, options){
	if (arguments.length == 1) { //arguments가 한개면
		options = $outline; //$outline 을 options에 대입(첫 번째 인자를 options로 간주)
		$outline = $(); //$outline은 빈 객체로 설정
	}
	// options는 항상 있다 왜냐면 함수 내부에서 $.extend 로 options를 병합하고 초기값을 설정하기 때문에 (options가 undefined여도 함수가 작동하긴 함)

	// $.extend를 사용해서 기본값을 설정해두고 사용자가 설정한 options를 덮어씀
	var opt = $.extend({
		data: {},
		url: "",
		cache: false,
		success: function(data, status, xhr) {
		}
	}, options);

	// $outline을 json형태로 변환
	var data = $component.toJson($outline);
	// data와 opt.data를 병합해서 data에 넣음 왜 ? 폼 데이터랑 options 데이터랑 합치는 것 같음
	data = $.extend(data, opt.data);
	// 값이 null이나 undefined인 속성 제거
	data = $component.removeEmptyJsonKey(data);
	// 마지막으로 opt.data에 할당
	opt.data = JSON.stringify(data);
	// opt에 추가설정, 여기서 하는 이유는 뭘까
	opt = $.extend( opt, {
		type: "post",
		contentType: "application/json; charset=utf-8",
	});


    return $.ajax(opt);
};
```


---


> 💡 **arguments ❓**  
> 함수 안에서 자동으로 제공되는 객체 / 함수에 전달된 모든 인수(값들) / 파라미터랑 비슷함  
> 함수의 파라미터 개수에 상관없이 전달된 값을 처리할 수 있음  
>   
> **파라미터와 차이점 ❓**  
>   
> 파라미터는 정해진 이름으로 값을 받지만 `arguments`는 이름이 없어도 됨  
> ex) ex01 참고  
>   
> 요즘은 `arguments` 보다 `...rest` 를 더 많이 씀  
>   
> ex) 스프레드 연산자(Spread Operator) & 레스트 파라미터(Rest Parameter) 참고


```javascript
function sum() {
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}
sum(1, 2, 3, 4);  // 1 + 2 + 3 + 4 = 10
```


### 스프레드 연산자(Spread Operator) & 레스트 파라미터(Rest Parameter)

1. 스프레드 연산자

값을 **펼친다** / **배열이나 객체**를 다룰 때 사용 / … + 배열이나 객체


```javascript
const arr = [1, 2, 3];
console.log(...arr); // 1 2 3 (배열을 펼침)

const newArr = [0, ...arr, 4];
console.log(newArr); // [0, 1, 2, 3, 4]
```

1. 레스트 파라미터

값을 **모은다**(배열로 묶음) / **함수 매개변수**에서 사용 / … + 매개변수 이름


```javascript
function printArgs(first, ...rest) {
    console.log(first);  // 첫 번째 값
    console.log(rest);   // 나머지 값들 (배열)
}
printArgs(1, 2, 3, 4); // 결과: 1, [2, 3, 4]
```


---


### $.extend


두 개 이상 객체를 합쳐주는 기능을 함


기본값을 설정하고, 필요한 값만 덮어쓸 때 자주 사용된다


```javascript
// 기본 문법
$.extend(target, object1, [objectN])

// target - 병합될 결과를 저장할 객체
// object1, [objectN] - 합칠 객체들, 여러 개를 넣을 수 있음
// 반환값 - target
```


```javascript
var defaults = { name: "User", age: 25 };
var userInput = { name: "Alice" };

var result = $.extend(defaults, userInput);
console.log(result); // { name: "Alice", age: 25 }
```


```javascript
var obj1 = { a: 1, b: 2 };
var obj2 = { b: 3, c: 4 };
var obj3 = { d: 5 };

var result = $.extend(obj1, obj2, obj3);
console.log(result); // { a: 1, b: 3, c: 4, d: 5 }
```


기본적으로 얕은 복사만 수행함 /  객체 내부에 또 다른 객체가 있으면 참조만 복사됨


> 💡 **얕은 복사** **❓**  
> 최상위 값만 복사 / 원본 객체와 같은 참조 공유 / 원본과 복사본이 연결되어 있음 / 빠르고 간단한 데이터 구조 복사  
>   
> **깊은 복사** **❓**  
>   
> 내부 객체까지 재귀적으로 복사 / 새로운 참조 생성 / 원본과 복사본이 완전히 독립적 / 상대적으로 느리고 복잡한 데이터 구조를 안전하게 복사

