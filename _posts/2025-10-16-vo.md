---
layout: post
title: "VO"
date: 2024-10-02
categories: [general]
tags: [Java]
excerpt_separator: ""
---



### 목적


불변의 값을 표현하고 객체의 동일성을 값으로 판단하는 객체


### 특징

1. 불변 객체이다 생성 후에는 그 값을 변경할 수 없다
2. 값의 동일성을 판단하는 데 있어서 객체의 참조가 아니라 값 자체로 판단한다 즉 두 VO가 같은 값을 가지면 그 두 객체는 동일하다고 간주한다
3. 비즈니스 로직 내에서 특정 값을 나타내고 그 값이 바뀌지 않아야 하는 경우에 사용한다

### 왜 쓰는지 ?

1. 데이터 무결성을 유지하기 위해 값을 변경하지 않는 객체가 필요할 때 사용한다
2. 불변성을 보장하여 객체가 변경되는 것을 방지한다 불변 객체는 다중 스레드 환경에서도 안전하게 사용할 수 있다
3. 값에 대한 동등성 비교를 할 때 참조가 아니라 값 자체로 비교하여 동일성을 판단할 수있다

```java
public class AddressVO {
    private final String street;
    private final String city;

    public AddressVO(String street, String city) {
        this.street = street;
        this.city = city;
    }

    public String getStreet() {
        return street;
    }

    public String getCity() {
        return city;
    }

    // 값 비교를 위해 equals와 hashCode 오버라이딩
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AddressVO that = (AddressVO) o;
        return street.equals(that.street) && city.equals(that.city);
    }

    @Override
    public int hashCode() {
        return Objects.hash(street, city);
    }
}
```


### 궁금


❓ **값을 참조가 아닌 값 자체로 판단해야 하는 이유?**


    🟰 **값 자체가 중요하기 때문, 값의 무결성 유지하기 위해**

1. **VO의 목적은 값 그 자체**를 나타내는 것 이다
    1. 예를 들어 두 주소 객체가 있을 때 이 두 객체가 메모리 상에서 서로 다른 위치에 있더라도 주소값(도시, 거리 등)이 동일하다면 두 주소는 같은 것으로 간주되어야 한다
    2. 객체의 참조가 다르더라도 값이 동일하다면 그 객체들은 논리적으로 동일하다고 보는 것이 올바른 해석이다

        ```java
        AddressVO address1 = new AddressVO("123 Main St", "New York");
        AddressVO address2 = new AddressVO("123 Main St", "New York");
        
        if (address1.equals(address2)) {
            System.out.println("Same address");
        }
        ```

2. 참조 비교는 객체의 **메모리 주소**를 비교하는 것에 불과하다
    1. 참조 비교는 두 객체가 같은 메모리 위치를 가리키고 있는지를 판단한다 하지만 실제로 많은 경우에 객체가 가리키는 메모리 주소보다는 그 **내부의 값**이 중요한 경우가 많다
    2. 참조가 같아야만 두 객체가 동일하다고 판단하면 서로 다른 위치에 있지만 값이 동일한 객체는 동일하지 않은 것으로 잘못 판단하게 된다

        ```java
        String s1 = new String("hello");
        String s2 = new String("hello");
        
        if (s1 == s2) {
            System.out.println("Same object");
        } else {
            System.out.println("Different objects");
        }
        
        if (s1.equals(s2)) {
            System.out.println("Same value");
        }
        ```

3. **불변성을 보장**하기 위해서
    1. 불변 객체는 생성 후 그 값을 절대 변경할 수 없기 때문에 값이 동일하면 그 객체는 논리적으로도 동일한 것으로 취급된다
    2. 불변성을 보장하면 객체 상태가 바뀌지 않으므로 안정성과 일관성을 유지할 수 있다
4. **비즈니스 로직**에서의 의미
    1. 실제 비즈니스 로직에서 두 객체가 논리적으로 동일하다고 간주되는 것은 참조가 아닌 값에 의존한다
5. 객체가 참조로 판단되면 생길 수 있는 **문제들**
    1. 다른 객체로 잘못 인식될 수 있고 처리가 잘못 될 수 있다

❓ **DTO 와 VO의 차이점**

1. DTO는 데이터 전달이 목적이기 때문에 getter/setter 외의 다른 로직이 필요 없다
2. VO는 값 그 자체를 나타내는 객체로써 getter/setter 외의 다른 로직이 있어도 무방하다
