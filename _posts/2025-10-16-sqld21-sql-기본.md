---
layout: post
title: "[SQLD]2-1. SQL 기본"
date: 2024-02-28
categories: [general]
tags: [Test]
excerpt_separator: ""
---



## 1. 관계형 데이터베이스 개요


### 데이터베이스 정의


특정 기업이나 조직 또는 개인이 필요에 의해 데이터를 일정한 형태로 저장해 놓은 것


데이터베이스 관리 소프트웨어 → DBMS


### 데이터베이스 발전


플로우차트(1960) → 계층형, 망형(1970) → 관계형(1980) → 객체관계형(1990)


### 관계형 데이터베이스


1970년 영국의 수학자 E.F.Codd 박사의 논문에서 처음 소개


파일 시스템 단점


    동시에 입력,수정,삭제 할 수 없기 때문에 정보의 관리가 어려움


    복사본 파일을 만들어 사용할 경우 데이터의 불일치성이 발생


관계형 DB의 장점


    정규화를 통해 이상 현상을 제거하고 데이터 중복을 피함


    동시성 관리, 병행 제어를 통해 데이터 공유


    데이터의 표현 방법 등 체계화 할 수 있고 데이터 표준화, 품질확보


    보안기능, 데이터 무결성 보장, 데이터 회복,복구 기능


### SQL(Structured Query Language)


최초 이름은 SEQUEL, 1986부터 ANSI/ISO를 통해 표준화되고 정의됨


각 벤더의 RDBMS는 표준화된 SQL 이외에 벤더 차별화 및 이용 편리성 위해 추가기능 구현


SQL 명령어는 세가지 SAVEPOINT 그룹인 DDL, DML, DCL로 구분


TCL의 경우 굳이 나눈다면 일부에서 DCL로 분류, 하지만 성격이 다름


**DML**(Data Manipulation Language, 조작) - Select, Insert, Update, Delete


**DDL**(Data Definition Language, 정의) - Create, Drop, Rename


**DCL**(Data Control Language, 제어) - Commit, Revoke


**TCL**(Transaction Control Language) - Commit, Rollback


### 테이블


데이터를 저장하는 객체로서 관계형 데이터베이스의 기본 단위


### 테이블의 분할


데이터의 불필요한 중복을 줄이는 것이 정규화, 이상현상 방지


### ERD(Entity Relationship Diagram)


구성요소 : 엔티티, 관계, 속성


표기법 : IE(Information Engineering) 표기법, Barker(Case Method) 표기법


## 2. DDL


### 데이터 유형

- **숫자 타입**

ANSI/ISO 기준 : Numeric, Decimal, Dec, Small Int, Integer, Int, Big int, Float, Real, Double Precision


SQL Server / Sybase : 작은 정수, 정수, 큰 정수, 실수 등 + Money, Small Money


Oracle : 숫자형 타입에 대해서 Number 한 가지 타입만 지원


벤더에서 ANSI/ISO 표준을 사용할 땐 기능을 중심으로 구현, 표준과 다른 용어 사용 허용

- **테이블의 컬럼이 가지고 있는 대표적인 유형**

    **Character(s)** : 고정길이 문자열, Char로 표현, s는 기본길이 1바이트, 최대 Oracle 2,000, SQL Server 8,000 바이트, 최대 s 만큼의 길이를 가짐, 빈 공간은 채워짐


    **Varchar(s)** : 가변길이 문자열, Character Varying의 약자, O VARCHAR2, S VARCHAR로 표현, s는 최소 1바이트, 최대 O 4000, S 8000 바이트, s 만큼의 최대 길이 하지만 가변적으로 줄어들어 조정


    ![Untitled.png](/aibOS/public/images/posts/28e0a7f9-f60c6e6c8217.png)


    **Numeric** : 정수, 실수 등 숫자 정보, O Number, S 10가지 이상 타입, O 처음 전체 자리 수, 그 뒤에 그 중 소수 부분 자리 수 지정


    **Datetime** : 날짜와 시각 정보, O Date, S DATETIME, O 1초 단위, S 3.33ms 단위로 관리

- **문자열 유형**

    CHAR과 VARCHAR의 차이


    CHAR에서 문자열 비교 : 공백을 채워서 비교


    VARCHAR 에서 비교 : 맨 처음부터 한 문자씩 비교 (공백도 하나의 문자로 취급)


### CREATE TABLE


테이블과 컬럼 정의 : 후보키 중 하나를 선정하여 기본키 지정


```sql
CREATE TABLE 테이블명 (
	컬럼명1 DATATYPE [DEFAULT 형식],
	컬럼명2 DATATYPE [DEFAULT 형식]
);
```


테이블 생성시 대소문자 구분은 하지 않는다


기본적으로 테이블이나 컬럼명 = 대문자


DATETIME 데이터 유형에는 별도로 크기를 지정하지 않는다


문자 데이터 유형은 반드시 가질 수 있는 최대 길이를 표시해야 한다


컬럼과 컬럼의 구분은 콤마로 하되, 마지막 컬럼은 콤마 x


컬럼에 대한 제약조건이 있으면 CONSTRAINT를 이용하여 추가할 수 있다


### 제약조건


데이터의 무결성을 유지하기 위한 데이터베이스의 보편적인 방법


PRIMARY KEY : 기본키, 하나의 테이블에 한 개만 지정 가능, 자동으로 UNIQUE 인덱스 생성, NULL 값 입력 불가 (기본키 제약 = 고유키, NOT NULL 제약)


UNIQUE KEY : 고유키, NULL 가능, 행을 고유하게 식별하기 위함


NOT NULL : NULL값 입력 금지


CHECK : 입력할 수 있는 값의 범위 등을 제한, TRUE FALSE 논리식을 지정


FOREIGN KEY : 외래키, 참조 무결성 옵션 선택 가능


NULL : 공집합, 0, 공백 등과 다른 정의되지 않은 미지의 값, 데이터 입력을 못하는 경우


DEFAULT : 기본값, 데이터 입력시 컬럼의 값이 지정되지 않을 때


### 생성된 테이블 구조 확인


```sql
DESCRIBE 테이블명;
exec sp_help 'dbo.테이블명' go
```


### SELECT 문장을 통한 테이블 생성 사례


CTAS(CREATE TABLE ~ AS SELECT ~)


기존 테이블 제약조건중 NOT NULL만 새로운 테이블에 복제


기본키, 고유키, 외래키, CHECK 등 다른 제약조건 사라짐


제약조건 추가 위해서는 ALTER TABLE 기능 사용해야함


S 에서는 SELECT ~ INTO ~ 를 활용하여 같은 결과


단 컬럼 속성에 IDENTITY 사용 = IDENTITY 속성 같이 적용


```sql
CREATE TABLE 테이블명_TEMP AS SELECT * FROM 테이블명;
SELECT * INTO 테이블명_TEMP FROM 테이블명;
```


### ALTER TABLE


**ADD COLUMN** : 새롭게 추가된 컬럼은 테이블의 마지막 컬럼, 위치는 지정 불가능


```sql
ALTER TABLE 테이블명 ADD 추가컬럼명 데이터유형;
```


**DROP COLUMN**


```sql
ALTER TABLE 테이블명 DROP COLUMN 삭제할 컬럼명;
```


**MODIFY COLUMN** : ALTER TABLE 을 이용해 컬럼의 데이터 유형, 디폴트 값, NOT NULL, 제약조건에 대한 변경을 포함


```sql
ALTER TABLE 테이블명 MODIFY (컬럼명 데이터유형 DEFAULT NOT NULL);
ALTER TABLE 테이블명 ALTER COLUMN 컬럼명 데이터유형 DEFAULT NOT NULL;
```


**컬럼 변경 시 고려해야 할 사항**


    컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다


    컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼 폭 줄이기 가능


    컬럼이 NULL 값만을 가지고 있으면 데이터 유형 변경 가능


    컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미침


    컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건 추가 가능


**RENAME COLUMN**


```sql
ALTER TABLE 테이블명 RENAME COLUMN 구컬럼명 TO 신컬럼명;
sp_rename 'dbo.테이블명.구컬럼명', '테이블명.신컬럼명','COLUMN';
```


**DROP CONSTRAINT**


```sql
ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
```


**ADD CONSTRAINT**


```sql
ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건 (컬럼명);
```


참조 무결성 제약조건을 추가하여 실수에 의한 테이블 삭제나 필요한 데이터의 의도하지 않은 삭제와 같은 불상사를 방지하는 효과를 볼 수 있다


**RENAME TABLE**


```sql
RENAME 구테이블명 TO 신테이블명;
sp_rename 'dbo.구테이블명', '신테이블명';
```


**DROP TABLE**


```sql
DROP TABLE 테이블명 CASCADE CONSTRAINT;
//CASCADE CONSTRAINT 옵션은 해당 테이블과 관계가 있었던 참조되는 제약조건에 대해서도 함께 삭제, S에서는 CASCADE 옵션 존재 X(테이블을 삭제하기 전에 참조하는 FOREIGN KEY 제약조건 또는 참조하는 테이블 삭제)
```


**TRUNCATE TABLE**


```sql
TRUNCATE TABLE 테이블명
```


테이블 자체가 삭제되는 것이 아니라 해당 테이블의 모든 행들이 제거되고 저장 공간을 재사용 가능하도록 해제, 구조 자체는 DROP TABLE 을 이용


DML로 분류할 수도 있지만 내부 처리방식이나 AUTO COMMIT 특성으로 DDL로 분류


DELETE 명령어와 처리방식 자체가 다름, 전체 데이터 삭제시 부하가 더 적어서 권장


BUT 오토커밋이기 때문에 정상적인 복구가 불가능하므로 사용 시 주의 요망


## 3. DML


**INSERT**


```sql
INSERT INTO 테이블명(컬럼리스트 / 생략 = 전체컬럼)
VALUES (리스트 순서에 맞춰 입력할 값 1:1 매핑하여 작성)
//컬럼의 데이터가 문자형일 경우 ' 으로 묶어서 입력, 숫자는 X
```


**UPDATE**


```sql
UPDATE 테이블명
SET 컬럼명 = 값;
```


**DELETE**


```sql
DELETE FROM 테이블명;(FROM 생략 가능)
```


**SELECT**


```sql
SELECT [ALL | DISTINCT] 컬럼1, 컬럼2 ...
FROM 테이블명;
//ALL : DEFAULT 옵션 (중복 데이터 모두 출력)
//DISTINCT : 중복 제거하여 한 건으로 출력
```


ALIAS 부여 : 조회된 결과에 별명(ALIAS, ALIASES)을 부여하여 컬럼 레이블은 변경 가능, 컬럼명 바로 뒤에 온다, 컬럼명과 ALIAS 사이에 AS 키워드 사용 가능, ALIASE가 공백, 특수문자를 포함할 경우나 대소문자 구분이 필요한 경우 “ 으로 묶어서 사용한다


**산술 연산자**


NUMBER와 DATE 자료형에 적용 (수학에서의 사칙연산과 동일)


우선순위 = () → * → / → + → -


**합성(Concatenation) 연산자**


문자와 문자를 연결하는 경우 : O ||, S +


두 벤더 모두 공통적으로 CONCAT(string1, string2, …) 함수를 이용해 동일하게 표현 가능


## 4. TCL


### 트랜잭션


데이터베이스의 논리적 연산단위


밀접히 관련되어 분리될 수 없는 한 개 이상의 데이터베이스 조작


하나의 트랜잭션에는 하나 이상의 SQL문이 포함


트랜잭션은 분할할 수 없는 최소의 단위


따라서 전부 적용하거나 전부 취소


즉 트랜잭션은 ALL OR NOTHING


### 트랜잭션을 컨트롤하는 TCL


**COMMIT** : 문제없이 처리된 트랜잭션을 데이터베이스에 반영시키는 것


**ROLLBACK** : 트랜잭션 수행 이전의 상태로 되돌리는 것


**트랜잭션 대상이 되는 SQL**


    UPDATE, INSERT, DELETE 등 데이터를 수정하는 DML문


    SELECT FOR UPDATE 등 배타적 LOCK을 요구하는 SELECT문


### 트랜잭션의 특성


은행 송금을 생각해보자


원자성(Atomicity) : 트랜잭션의 연산은 모두 적용되든지 모두 취소되어야 한다


일관성(Consistency) : 트랜잭션의 실행 전 DB에 이상이 없다면 실행 후에도 같아야 한다


고립성(Isolation) : 트랜잭션 실행 중 다른 트랜잭션의 영향을 받아선 안된다


지속성(Durability) : 트랜잭션이 성공적으로 수행되면 영구적으로 반영되어 저장된다


### **COMMIT**


입력, 수정, 삭제한 자료에 대하여 문제가 없을 경우 COMMIT 명령어로 변경 사항을 적용


**COMMIT 이전의 상태**


    단지 Memory Buffer 에만 영향을 주고 이전 상태로 복구가 가능


    현재 사용자는 SELECT문으로 변경 결과 확인 가능한 상태


    다른 사용자는 현재 사용자가 수행한 결과 확인 불가능


    변경된 행은 잠금이 설정되어 다른 사용자가 변경 불가능


**COMMIT 이후의 상태**


    데이터에 대한 변경사항이 데이터베이스에 영구적 반영


    이전 데이터는 영원히 잃어버린다


    모든 사용자가 결과를 조회할 수 있다


    관련 행에 잠금이 해제되고 다른 사용자가 행을 조작할 수 있다


* SQL SERVER는 기본적으로 DML 구문도 AUTO COMMIT 모드이다 (AUTO 암시적 명시적)


### ROLLBACK


테이블 내 입력, 수정, 삭제한 데이터에 대해서 COMMIT 이전에 변경 사항을 취소하는 기능


변경 사항이 취소되고 관련 행 잠금이 풀리며 다른 사용자들이 데이터 변경 가능


**롤백 후 데이터 상태**


    데이터에 대한 변경사항은 취소됨


    이전 데이터가 다시 재저장됨


    관련 행에 대한 잠금이 풀리고 다른 사용자들이 행 조작 가능


### COMMIT 과 ROLLBACK 사용 효과


데이터 무결성 보장


영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능


논리적으로 연관된 작업을 그룹핑하여 처리 가능


### SAVEPOINT


저장점을 정의하면 롤백을 할 경우 전체 롤백이 아닌 저장점까지의 일부만 롤백할 수 있다


복수의 저장점 정의 가능, 동일 이름으로 저장점을 저장 시 나중에 정의한 저장점이 유효


저장점을 정의하고 저장점으로 롤백한다


```sql
SAVEPOINT 포인트이름;
ROLLBACK TO 포인트이름;

SAVE TRANSACTION 포인트이름;
ROLLBACK TRANSACTION 포인트이름;
```


한 저장점으로 돌리고 나서 그보다 더 미래로 다시 되돌릴 수 없다


특정한 저장점까지 롤백하면 그 저장점 이후에 설정한 저장점은 모두 무효가 된다


저장점 없이 롤백하면 모든 변경사항을 취소한다


## 5. WHERE 절


원하는 자료만을 검색하기 위해서 이용하여 자료 제한


WHERE 절에 조건이 없는 FTS(FULL TABLE SCAN) 문장은 SQL 튜닝 1차 검토 대상


(FTS가 무조건 나쁜 것은 아님, 병렬 처리 등을 이용해 유용하게 사용하는 경우도 많음)


### **연산자의 종류**


비교 연산자 : =, >, ≥, <, ≤


SQL 연산자 : BETWEEN A AND B, IN (list), LIKE ‘비교문자열’, IS NULL


논리 연산자 : AND, OR, NOT


부정 비교 연산자 : !=, ^=, <>, NOT 컬럼명 =, NOT 컬럼명>


부정 SQL 연산자 : NOT BETWEEN A AND B, NOT IN (list), IS NOT NULL


### 문자 유형간의 비교 방법


**비교 연산자의 양쪽이 모두 CHAR 타입인 경우**


길이가 서로 다른 CHAR 이면 작은 쪽에 Space 추가하여 길이 같게 한 후에 비교


서로 다른 문자가 나올 때까지 비교


달라진 첫 번째 문자의 값에 따라 크기를 결정


Blank의 수만 다르다면 서로 같은 값으로 결정


**비교 연산자의 어느 한 쪽이 VARCHAR 타입인 경우**


서로 다른 문자가 나올 때까지 비교


길이가 다르다면 짧은 쪽이 끝날 때까지만 비교한 후 길이가 긴 것이 크다고 판단


길이가 같고 다른 것이 없다면 같다고 판단


VARCHAR는 NOT NULL 까지 길이를 말함


**상수값과 비교할 경우**


상수 쪽을 변수 타입과 동일하게 바꾸고 비교


변수 쪽이 CHAR 타입이면 위의 CHAR 타입 경우를 적용


변수 쪽이 VARCHAR 타입이면 위의 VARCHAR 타입 경우를 적용


### 연산자의 우선순위


() → NOT → 비교연산자, SQL 비교연산자 → AND → OR


### SQL 연산자


**BETWEEN A AND B** : A와 B 값 사이에 있는 값들 (A, B 포함)


**IN (LIST)** : 리스트에 있는 값 중에서 하나라도 일치 여부


**LIKE ‘비교문자열’** : 형태 일치 여부(와일드카드 : %(0개 이상 문자열), _(1개 단일 문자))


**IS NULL** : NULL 값인지 여부


### 논리 연산자


AND : 앞의 조건과 뒤의 조건이 모두 TRUE 일 경우 TRUE 반환 (동시만족)


OR : 앞이나 뒤의 조건 중 한 개라도 TRUE 이면 TRUE 반환


NOT : 뒤에 오는 조건절에 반대되는 결과 반환


### 부정 논리 연산자


**!=, ^=, <>** : 같지 않다


**NOT 컬럼명** : ~와 같지 않다


**NOT 컬럼명** : ~보다 크지 않다


### 부정 SQL 연산자


**NOT BETWEEN A AND B** : A 부터 B 까지의 값 사이에 포함되지 않는다(A, B도 값에 포함)


**NOT IN (LIST)** : LIST 에 일치하는 값이 없다


**IS NOT NULL** : NULL 값을 갖지 않는다


### ROWNUM, TOP


WHERE 절에서 행의 개수를 제한하는 목적으로 사용


한 건의 행은 = 연산자 사용 가능, 두 건 이상 부터는 = 사용 불가


```sql
SELECT 컬럼명 FROM 테이블명 ROWNUM <= N OR ROWNUM < N;
//고유키나 인덱스 생성 가능 -> UPDATE 테이블명 SET 컬럼명 = ROWNUM

SELECT TOP(N) 컬럼명 FROM 테이블명;
//TOP(EXPRESSION), PERCENT, WITH TIES
//EXPRESSION : 행 수 지정
//PERCENT : 결과 집합의 처음 몇 % 행만 반환
//WITH TIES : ORDER BY 절이 지정된 경우만 사용 가능, 마지막 행 같은 값 추가 출력
```


## 6. 함수


### 내장함수(Built-In Function)


함수는 다양한 기준으로 분류 가능


    벤더에서 제공하는 함수인 내장 함수(Built-In Function)


    사용자가 정의할 수 있는 함수(User Defined Function)


SQL을 더욱 강력하게 해주고 데이터 값을 간편하게 조작하는데 사용


벤더별로 가장 큰 차이를 보이는 부분이라지만 핵심적인 기능들은 이름, 표기법이 달라도 비슷


내장함수는 다시 함수의 입력 값에 따라 단일행 함수와 다중행 함수로 나뉜다


함수는 입력값이 아무리 많아도 출력값은 하나라는 다:1 관계라는 중요한 특징을 가짐


단일행 함수 : 단일행 내에 있는 하나의 값 또는 여러 값이 입력 인수로 사용


다중행 함수 : 여러 레코드의 값들을 입력 인수로 사용


### 단일행 함수


**:** 문자형, 숫자형, 날짜형, 변환형, NULL 관련 함수


### **문자형 함수**


**LOWER**(문자열) : 문자열의 알파벳 문자를 소문자로 변경


**UPPER**(문자열) : 문자열의 알파벳 문자를 대문자로 변경


**ASCII**(문자) : 문자나 숫자를 ASCII 코드 번호로 출력


**CHR/CHAR**(ASCII번호) : ASCII코드 번호를 문자나 숫자로 출력


**CONCAT**(문자열1, 문자열2) : 문자열 연결(|| OR + 와 동일 기능)


**SUBSTR/SUBSTRING**(문자열, m, n) : 문자열 중 m 위치부터 n개의 문자 반환 (n 생략시 마지막 문자까지)


**LENGTH/LEN**(문자열) : 문자열의 개수(길이)를 숫자값으로 반환


**LTRIM**(문자열[, 지정문자]) : 문자열의 앞쪽부터 확인해 지정문자가 처음 나타나는 동안 해당 문자를 제거(기본값 공백)


**RTRIM**(문자열[, 지정문자]) : 문자열의 뒤쪽부터 확인해 지정문자가 처음 나타나는 동안 해당 문자를 제거(기본값 공백)


**TRIM**([leading | trailing | both] 지정문자 FROM 문자열) : 머리말, 꼬리말, 양쪽 지정문자 제거 기본값 BOTH, S 에서는 TRIM 함수에 지정문자 사용 불가(공백만 제거 가능)


DUAL 테이블은 데이터 사전과 함께 O 에서 자동으로 생성되는 기본 테이블


SYS의 스키마에 있으며 모든 사용자가 엑세스 가능


VARCHAR2(1) 정의의 DUMMY 열 한 개


값을 가지는 하나의 행도 포함, 사용자가 계산이나 사용자 함수 등을 실행 할 경우 사용


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-5fb0de3a5296.png)


### **숫자형 함수**


**ABS**(숫자) : 절대값 반환


**SIGN**(숫자) : 양수, 0, 음수 판별(부호)


**MOD**(숫자1, 숫자2) : 숫자1을 숫자2로 나누어 나머지 값 반환(%)


**CEIL/CEILING**(숫자) : 크거나 같은 최소 정수 반환(정수 값으로 올림)


**FLOOR**(숫자) : 작거나 같은 최대 정수 반환(정수 값으로 버림)


**ROUND**(숫자[, m]) : 소수점 m자리에서 반올림(생략시 0)


**TRUNC**(숫자[, m]) : 소수 m자리 뒤로 잘라서 버림(생략시 0) O Only


**SIN, COS, TAN** : 삼각함수 값 반환


**EXP, POWER, SQRT, LOG, LN** : 지수, 거듭제곱, 제곱근, 자연로그


### **날짜형 함수**


**SYSDATE/GENDATE** : 현재 날짜와 시각을 반환


**EXTRACT**(’YEAR’ | ’MONTH’ | ‘DAY’ from d) : 연월일 데이터를 추출


**DATEPART**(’YEAR’ | ‘MONTH’ | ‘DAY’ from d) : 시간 분 초도 가능함


**TO_NUMBER**(TO_CHAR(d, ‘YYYY’)) / YEAR(d) : 위와 같은 기능, TO_NUMBER 제외시 문자형 출력


날짜 + 숫자 = 날짜 / 날짜 - 숫자 = 날짜 / 날짜 + 날짜 = 날짜 수 / 날짜 + 숫자/24 = 날짜 + 시간


### **변환형 함수**


명시적 변환 : 데이터가 변환형 함수로 변환하도록 명시


암시적 변환 : 데이터베이스가 자동으로 변환하여 계산


**ORACLE**


TO_NUMBER(문자열) : alphanumeric 문자열을 숫자로 변환


TO_CHAR(숫자 | 날짜[, FORMAT]) : 숫자, 날짜를 주어진 FORMAT으로 문자열 타입 변환


TO_DATE(문자열[, FORMAT]) : 문자열을 주어진 FORMAT으로 날짜 타입 변환


**SQL SERVER**


CAST(expression AS data_type[(length)]) : expression을 목표 타입으로 변환


CONVERT(data_type [(length)] expression[, style]) : expression 목표 타입 변환


### CASE 표현


CASE 표현은 IF-THEN-ELSE 논리와 유사한 방식으로 표현식을 작성하여 SQL의 비교 연산 기능을 보완하는 역할을 함


ANSI/ISO 표준에는 CASE Expression이라고 표시


함수와 같은 성격을 가지고 있으며 Oracle의 DECODE 함수와 같은 기능을 함


```sql
SELECT 컬럼명
	CASE
	WHEN 조건
	THEN 조건이 TRUE 일 때 반환
	ELSE 조건이 FALSE 일 때 반환
	END AS 컬럼명
FROM 테이블명;
```


SIMPLE_CASE_EXPRESSION 조건 TRUE 이면 해당 THEN 절 수행 FALSE이면 ELSE 절 수행


(EQUL(=) 조건만 사용할 경우 간단하게 사용 DECODE와 기능 동일)


```sql
CASE
	SIMPLE_CASE_EXPRESSION (인수 WHEN 조건 THEN 반환값)
	ELSE 표현절 (ELSE 반환값)
END
```


SEARCHED_CASE_EXPRESSION 조건 TRUE 이면 해당 THEN 절 수행, FALSE 이면 ELSE 절(= 뿐만 아니라 부등호 등을 이용한 여러 조건절 사용 가능, 다양한 조건 적용 가능)


```sql
CASE
	SEARCHED_CASE_EXPRESSION 조건(WHEN 조건 THEN 반환값 * N)
	ELSE 표현절 (ELSE 반환값)
END
```


ORACLE 함수로 표현식의 값이 기준값1이면 값1 출력, 기준값2 이면 값2 출력


기준값이 없으면 디폴트 값 출력 CASE 의 SIMPLE_CASE_EXPRESSION 조건과 동일


```sql
DECODE(표현식, 기준값1, 값1, 기준값2, 값2, ... , DEFAULT 값) DEFAULT 생략시 NULL
```


### NVL / IS NULL 함수


테이블 생성 시 NOT NULL, PK로 지정하지 않은 모든 데이터 유형은 NULL 값을 가질 수 있음


NULL 값을 포함하는 연산의 경우 결과 값도 NULL 이다


NVL/ISNULL(판단대상, 대체값) : 판단대상의 값이 NULL이면 대체값 출력 (판단대상과 대체값 데이터 타입이 같아야 함)


NULLIF(판단대상, 비교대상) : 판단대상 = 비교대상이면 NULL, 아닐 경우 판단대상 리턴


COALESCE(표현식1, 표현식2, …) : NULL이 아닌 최초의 표현식 리턴, 없으면 NULL 리턴


### 공집합


SELECT1 와 같은 조건이 대표적인 공집합을 발생시키는 쿼리


FROM DUAL 조건에 맞는 데이터가 한 건도 없는 경우를 공집합이라고 함


WHERE 1 = 2; NULL 과는 또 다르게 이해해야 함


## GROUP BY HAVING 절


### 집계함수(Aggregate Function)


여러 행들의 그룹이 모여서 그룹당 단 하나의 결과를 돌려주는 함수


GROUP BY 절은 행들을 소그룹화


SELECT 절, HAVING 절, ORDER BY 절에 사용


집계함수명(ALL | DISTINCT 컬럼/표현식) - Default = All


주로 숫자 유형에 사용하며 **MAX, MIN, COUNT** 함수는 문자, 날짜에도 적용 가능


**COUNT**(*) : NULL 값을 포함한 모든 행의 수를 출력


**COUNT**(표현식) : NULL 값인 것들을 제외한 행의 수를 출력


**SUM**([DISTINCT|ALL] 표현식) : NULL을 제외한 합계 출력


**AVG**([DISTINCT|ALL] 표현식) : NULL을 제외한 평균 출력


**MAX**([DISTINCT|ALL] 표현식) : 최대값 출력(문자, 날짜 데이터 사용 가능)


**MIN**([DISTINCT|ALL] 표현식) : 최소값 출력(문자, 날짜 데이터 사용 가능)


**STDDEV**([DISTINCT|ALL] 표현식) : 표준 편차를 출력


**VARIAN**([DISTINCT|ALL] 표현식) : 분산을 출력


벤더별로 기타 다양한 통계 함수를 제공


### GROUP BY 절


FROM 절과 WHERE 절 뒤에 오며 데이터들을 작은 그룹으로 분류하여 소그룹에 대한 항목별 통계 정보를 얻을 때 추가로 사용한다


```sql
SELECT DISTINCT 컬럼명 ALIAS명
FROM 테이블명
WHERE 조건식
GROUP BY 컬럼/표현식
HAVING 그룹의 조건식;
```


### GROUP BY 절과 HAVING 절의 특성


GROUP BY 절을 통해 소그룹별 기준을 정한 뒤 SELECT 절에 집계 함수 사용


집계 함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행


집계 함수는 WHERE 절에는 올 수 없음(GROUP BY 절보다 WHERE 절이 먼저 수행되니까)


WHERE 절은 전체 데이터를 GROUP 으로 나누기 전에 행들을 미리 제거하는 역할


HAVING 절은 GROUP BY 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건을 표시할 수 있음


GROUP BY 절에 의한 소그룹별로 만들어진 집계 데이터 중 HAVING 절에서 제한 조건을 두어 조건을 만족하는 내용만을 출력


HAVING 절은 일반적으로 GROUP BY 절 뒤에 위치


GROUP BY 절에서는 ALIAS명을 사용할 수 없다


원칙적으로 ORDER BY 절 명시해야 정렬(일부 DB 과거 버전에서 자동 오름차순 정렬)


### HAVING 절


WHERE 절에서는 집계함수를 사용할 수 없다


GROUP BY 절보다 HAVING 절을 앞에 사용해도 같은 결과가 나오지만 논리적으로 순서를 지키는 것이 좋음


가능하면 WHERE 절에서 조건절을 적용하여 GROUP BY 계산 대상을 줄이는 것이 효과적


HAVING 절은 SELECT 절에 사용되지 않은 컬럼이나 집계 함수가 아니더라도 GROUP BY 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건을 표시 가능


WHERE 절 조건 변경은 대상 데이터 개수가 변경되므로 결과 데이터 값 변경 가능성 O


HAVING 절 조건 변경은 결과 데이터 변경은 없고 출력되는 레코드 개수만 변경 가능성 O


### CASE 표현을 활용한 월별 데이터 집계


제 1 정규화로 인해 반복되는 컬럼의 경우 구분 컬럼을 두고 여러 개의 레코드로 만들어진 집합을 정해진 컬럼 수만큼 확장해서 집계 보고서를 만드는 기법(DECODE 도 동일 기능)


하나의 데이터에 여러 번 CASE 표현, 집계함수 사용 후 그룹으로 묶음


### 집계함수와 NULL 처리


다중행 함수에 NVL 함수를 사용하면 부하 발생 → 굳이 ?


다중행 함수는 입력 값으로 전체 건수가 NULL 값인 경우만 함수의 결과가 NULL


전체 건수 중에서 일부만 NULL인 경우는 NULL 인 행을 연산에서 제외


CASE 표현 사용시는 ELSE 절을 생략하면 DEFAULT 값이 NULL


→ 같은 결과를 얻을 수 있다면 가능한 ELSE 절의 상수값을 지정하지 않거나 ELSE 절 생략


O 의 DECODE 함수는 네 번째 인자 지정하지 않으면 DEFAULT 값이 NULL


## ORDER BY 절


### ORDER BY 정렬


컬럼명 대신 SELECT 절에서 사용한 ALIAS 명이나 컬럼 순서를 나타내는 정수도 사용 가능하다


기본적인 정렬 순서는 오름차순(ASC)이며 SQL 문장의 제일 마지막에 위치한다


```sql
SELECT 컬럼명 ALIAS명
FROM 테이블명
WHERE 조건식
GROUP BY 컬럼/표현식
HAVING 그룹조건식
ORDER BY 컬럼/표현식 [ASC|DESC]
```


숫자형 타입은 오름차순 시 작은 값부터 출력


날짜형 타입은 오름차순 시 빠른 날부터 출력


O는 NULL 값을 가장 큰 값, S 는 NULL 값을 가장 작은 값으로 간주


컬럼의 순서는 향후 유지보수성이나 가독성이 떨어지므로 가능한 컬럼명이나 ALIAS명 권고


### SELECT 문장의 실행순서

1. SELECT 컬럼명 ALIAS명

1. FROM 테이블명

1. WHERE 조건식
2. GROUP BY 컬럼/표현식
3. HAVING 그룹조건식
4. ORDER BY 컬럼/표현식
1. 발췌 대상 테이블 참조 FROM
2. 발췌 대상 데이터가 아닌 것은 제거 WHERE
3. 행들을 소그룹화 GROUP BY
4. 그룹핑된 값의 조건에 맞는 것만을 출력 HAVING
5. 데이터 값을 출력/계산 SELECT
6. 데이터를 정렬 ORDER BY

옵티마이저가 SQL 문장의 SYNTAX, SEMANTIC 에러를 점검하는 순서이기도 하다


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-93bdd417cd95.png)


 


**결과적으로 SELECT 절에서는 그룹핑 기준과 숫자 형식 컬럼의 집계 함수를 사용할 수 있지만 그룹핑 기준 외의 문자 형식 컬럼은 정할 수 없다**


### TOP N 쿼리


**ROWNUM** : O 에서 순위가 높은 N 개의 로우를 추출하기 위해 ORDER BY 절과 WHERE 절의 ROWNUM 조건을 같이 사용하는 경우가 있는데 이 두 조건으로는 원하는 결과를 얻을 수 없다


ORDER BY 절은 결과 집합을 결정하는 데 관여하지 않는다


→ 인라인 뷰를 활용하여 추출하고자 하는 집합을 먼저 정렬한 후에 ROWNUM을 적용시킴으로써 결과에 참여하는 순서와 추출되는 행의 순서를 일치시킨다


ROWNUM 조건이 ORDER BY 절보다 먼저 처리되는 WHERE 절에서 처리하므로 정렬 후 원하는 데이터를 얻기 위해서는 인라인 뷰에서 먼저 정렬을 수행한 후 메인쿼리에서 ROWNUM 조건을 사용해야 한다


**TOP** : S는 TOP 조건을 사용하게 되면 별도 처리 없이 관련 ORDER BY 절의 데이터 정렬 후 원하는 일부 데이터만 쉽게 출력한다


TOP 절을 사용하여 결과 집합으로 반환되는 행의 수를 제한할 수 있다


**WITH TIES** 옵션은 ORDER BY 절의 조건 기준으로 TOP N의 마지막 행으로 표시되는 추가 행의 데이터가 같을 경우 N + 동일 정렬 순서 데이터를 추가로 반환하도록 하는 옵션


TOP (Expression) PERCENT WITH TIES


## JOIN


### 개요


두 개 이상의 테이블들을 연결 또는 결합하여 데이터를 출력하는 것


관계형 데이터베이스의 가장 큰 장점이면서 대표적인 핵심 기능


일반적인 경우 행들은 PK 나 FK 값의 연관에 의해 JOIN 이 성립된다


어떤 경우에는 이러한 PK FK 관계가 없어도 논리적인 값들의 연관만으로 JOIN 성립이 가능


하나의 SQL 문장에서 여러 테이블을 조인해서 사용할 수도 있다


주의점은 FROM 절에 여러 테이블이 나열되더라도 SQL에서 데이터를 처리할 때는 두 개의 집합 간에만 JOIN이 일어난다


FROM 절에 A B C 세 개의 테이블이 나열되었더라도 특정 두개의 테이블만 먼저 조인되고 그 조인된 새로운 결과 집합과 남은 한 개의 테이블이 다음 차례로 조인되는 것이다


### EQUAL JOIN


두 테이블 간에 컬럼 값들이 서로 정확히 일치하는 경우에 사용


대부분 PK-FK 관계를 기반으로 한다 그러나 일반적으로 테이블 설계시에 나타난 PK-FK의 관계를 이용하는 것이지 반드시 PK-FK 관계로만 성립하는 것은 아니다


JOIN의 조건은 WHERE 절에 기술하게 되는데 ‘=’ 연산자를 사용해서 표현한다


```javascript
SELECT 테이블1.컬럼명, 테이블2.컬럼명,
FROM 테이블1, 테이블2
WHERE 테이블1.컬럼명1 = 테이블2.컬럼명2;
```


```javascript
SELECT 테이블1.컬럼명, 테이블2.컬럼명,
FROM 테이블1 INNER JOIN 테이블2 ON 테이블1.컬럼명1 = 테이블2.컬럼명2
```


n개의 테이블의 조인에서 JOIN 조건은 대상 테이블의 개수에서 하나를 뺀 n-1개 이상 필요


JOIN 조건은 WHERE 절에 기술하며 JOIN은 두 개 이상의 테이블에서 필요한 데이터를 출력하기 위한 가장 기본적인 조건이다


조건절에 ALIAS명 사용 가능


WHERE 절에서 JOIN 조건 이외의 검색 조건에 대한 조건을 덧붙여 사용할 수 있다
(조인 조건 명시 후 논리 연산자를 이용하여 부수적인 제한 조건 추가로 입력)


### JOIN 시 주의 사항


만약 테이블에 대한 ALIAS 명을 적용하여 SQL 문장을 작성했을 경우 WHERE 절과 SELECT 절에는 테이블명이 아닌 ALIAS 를 사용해야 한다


권장사항은 아니지만 하나의 SQL 문장 니에서 유일한 컬럼명이면 ALIAS를 붙이지 않아도 됨


### NON EQUAL JOIN


두 개의 테이블 간 컬럼 값들이 서로 정확하게 일치하지 않는 경우


‘=’ 연산자가 아닌 다른 (Between, 부등호 등) 연산자를 이용하여 JOIN을 수행하는 것


두 개의 테이블이 PK-FK로 연관관계를 가지거나 논리적으로 같은 값이 존재하는 경우에는 ‘=’ 연산자를 이용하여 EQUAL JOIN을 사용한다 그러나 컬럼 값들이 정확하게 일치하지 않는 경우에는 사용할 수 없다


이런 경우 NON EQUAL JOIN을 시도할 수 있으나 데이터 모델에 따라서 불가능한 경우도 있다


```javascript
SELECT 테이블1.컬럼명, 테이블2.컬럼명,
FROM 테이블1, 테이블2
WHERE 테이블1.컬럼명1 BETWEEN 테이블2.컬럼명1 AND 테이블2.컬럼명2
```


### JOIN이 필요한 이유


정규화에서부터 출발하는데


정규화란 불필요한 데이터의 정합성을 확보하고 이상현상 발생을 피하기 위해 테이블을 분할하여 생성하는 것 사실 데이터 웨어하우스 모델처럼 하나의 테이블에 모든 데이터를 집중시켜놓고 그 테이블로부터 필요한 데이터를 조회할 수도 있다 그러나 이러한 경우 가장 중요한 데이터의 정합성에 더 큰 비용을 지불해야하며 데이터를 추가/삭제/수정 하는 작업 역시 상당한 노력이 요구될것이다


성능 측면에서도 간단한 데이터를 조회하는 경우에도 규모가 큰 테이블에서 필요한 데이터를 찾아야 하기 때문에 오히려 검색 속도가 떨어질 수도 있다


테이블을 정규화하여 데이터를 분할하게 되면 위와 같은 문제는 자연스럽게 해결 된다 특정 요구조건을 만족하는 데이터들을 분할된 테이블로부터 조회하기 위해서는 테이블 간에 논리적인 연관관계가 필요하고 그런 관계성을 통해서 다양한 데이터들을 출력할 수 있는 것이다 그리고 이런 논리적인 관계를 구체적으로 표현하는 것이 바로 조인 조건이다


관계형 데이터베이스의 큰 장점이면서 SQL 튜닝의 주요 대상이 되는 JOIN을 잘못 기술하게 되면 시스템 자원 부족이나 과다한 응답시간 지연을 발생시키는 주요 원인이 되므로 JOIN 조건은 신중하게 작성해야 합니다

