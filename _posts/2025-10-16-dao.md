---
layout: post
title: "DAO"
date: 2024-10-07
categories: [general]
tags: [Java]
---


데이터베이스에 접근하고 데이터를 처리하는 로직을 담당하는 객체


즉 어플리케이션의 비즈니스 로직과 데이터베이스 작업(삽입, 조회, 수정, 삭제 등)을 분리하여 데이터베이스와 상호작용하는 코드를 별도의 클래스로 관리하는 역할을 한다


### 목적

- 비즈니스 로직과 데이터 접근 로직을 분리하여 코드의 유지보수성을 높인다
- 데이터베이스 관련 코드의 재사용성을 증가시킨다
- 다양한 데이터베이스나 데이터 소스에 대한 추상화를 제공하여 데이터베이스가 바뀌더라도 비즈니스 로직에 영향을 미치지 않도록 한다

### 기본 구조

1. DAO 인터페이스 : 데이터베이스에서 수행할 수 있는 작업(삽입, 조회, 수정, 삭제 등)을 정의하는 인터페이스
2. DAO 구현 클래스 : DAO 인터페이스를 구현한 클래스이다 여기서 실제 데이터베이스와의 상호작용을 수행한다
3. 모델 클래스(또는 엔티티) : 데이터베이스의 테이블과 매핑되는 객체로 보통 어플리케이션 내에서 데이터를 주고받는 데 사용된다

### 예시

1. 모델 클래스(엔티티 클래스) : 데이터베이스 테이블의 구조를 나타내는 객체

```java
public class User {
    private int id;
    private String name;
    private String email;

    // 생성자, getter, setter
    public User(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

1. DAO 인터페이스

```java
public interface UserDAO {
    // 사용자 추가
    void addUser(User user);

    // ID로 사용자 찾기
    User getUserById(int id);

    // 모든 사용자 리스트 반환
    List<User> getAllUsers();

    // 사용자 업데이트
    void updateUser(User user);

    // 사용자 삭제
    void deleteUser(int id);
}
```

1. DAO 구현 클래스

```java
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class UserDAOImpl implements UserDAO {
    private static final String JDBC_URL = "jdbc:mysql://localhost:3306/mydb";
    private static final String JDBC_USER = "root";
    private static final String JDBC_PASSWORD = "password";

    private Connection getConnection() throws SQLException {
        return DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);
    }

    @Override
    public void addUser(User user) {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        try (Connection conn = getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, user.getName());
            stmt.setString(2, user.getEmail());
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @Override
    public User getUserById(int id) {
        String sql = "SELECT * FROM users WHERE id = ?";
        try (Connection conn = getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return new User(rs.getInt("id"), rs.getString("name"), rs.getString("email"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public List<User> getAllUsers() {
        List<User> users = new ArrayList<>();
        String sql = "SELECT * FROM users";
        try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) {
            ResultSet rs = stmt.executeQuery(sql);
            while (rs.next()) {
                users.add(new User(rs.getInt("id"), rs.getString("name"), rs.getString("email")));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return users;
    }

    @Override
    public void updateUser(User user) {
        String sql = "UPDATE users SET name = ?, email = ? WHERE id = ?";
        try (Connection conn = getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, user.getName());
            stmt.setString(2, user.getEmail());
            stmt.setInt(3, user.getId());
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void deleteUser(int id) {
        String sql = "DELETE FROM users WHERE id = ?";
        try (Connection conn = getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, id);
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```


### 장점

1. **책임 분리(SRP)** : 데이터베이스 접근 로직을 비즈니스 로직과 분리하여 코드를 더 깔끔하고 모듈화된 형태로 유지할 수 있다
2. **유지보수성 향상** : 데이터베이스에 대한 수정(예 : 쿼리 변경, DB 교체 등)이 필요할 때 DAO  레이어만 수정하면 되므로 다른 레이어에 영향을 미치지 않는다
3. **재사용성** : DAO 클래스는 다양한 비즈니스 로직에서 재사용할 수 있어 코드의 중복을 줄일 수 있다
4. **테스트 용이성** : DAO 레이어는 별도로 테스트 가능하며 데이터베이스와의 상호작용을 목(mock) 객체로 대체할 수 있어 단위 테스트 작성이 용이하다

### 단점

1. **추상화에 따른 복잡성 증가** : DAO 패턴을 사용하면 인터페이스와 클래스가 추가되므로 코드의 복잡도가 증가할 수 있다
2. **데이터베이스 의존성** : DAO 클래스는 데이터베이스와 직접 상호작용하기 때문에 데이터베이스 구조가 변경되면 해당 DAO 클래스도 수정해야 한다
