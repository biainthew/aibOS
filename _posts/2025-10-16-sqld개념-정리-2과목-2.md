---
layout: post
title: "[SQLD]개념 정리 2과목 2"
date: 2024-03-05
categories: [general]
tags: [Test]
excerpt_separator: ""
---



# 2과목 Part 2


## 그룹함수


### GROUPING SETS


**A별, B별** 그룹 연산 결과 출력


나열 연산 중요하지 않음


기본 출력에 총계는 출력되지 않음


NULL 혹은 () 사용하여 전체 총 합 출력 가능


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-a4f0c0220b1f.png)


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-eade04b56d75.png)


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-6db3802a21df.png)


### ROLLUP


A별, (A,B) 별 전체 그룹 연산 결과 출력


나열 대상의 순서가 중요함


기본적으로 전체 총계가 출력됨


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-ff325e5f381f.png)


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-8df27ccd979d.png)


### CUBE


A별, B별, (A,B)별, 전체 그룹 연산 결과 출력됨


그룹으로 묶을 대상의 나열 순서 중요하지 않음


기본적으로 전체 총계가 출력됨


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-6fde50ce69bd.png)


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-cf924a471ad9.png)


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-9f2c9ddec292.png)


## 윈도우 함수


서로 다른 행의 비교나 연산을 위해 만든 함수


GROUP BY 쓰지 않고 그룹 연산 가능


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-e235d60cd19c.png)


**PARTITION BY 절** : 출력할 총 데이터 수 변화 없이 그룹연산 수행할 GROUP BY 컬럼


**ORDER BY 절** : RANK 의 경우 필수, 누적값 출력 시 사용


**ROWS | RANGE BETWEEN A AND B** : 연산 범위 설정, ORDER BY 필수


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-6a02004ea446.png)


### 그룹 함수의 형태를 지닌 윈도우 함수


SUM, COUNT, AVG, MIN, MAX


OVER 절을 사용하여 윈도우 함수로 사용 가능


반드시 연산할 대상을 그룹함수의 입력값으로 전달


### SUM OVER, AVG, MIN, MAX


: 전체 총 합, 그룹별 총 합 출력 가능


예) 각 직원 정보와 함께 급여 총 합 출력 → 그룹함수 결과는 SELECT 절에 쓸 수 없음


→ 윈도우 함수를 사용하면 원뎁스로 작성 가능 → 성능 굳


### 윈도우 함수의 연산 범위 : 집계 연산 시 행의 범위 설정 가능

1. **ROWS, RANGE 차이**
    1. **ROWS** : 값이 같더라도 각 행 씩 연산
    2. **RANGE** : 같은 값의 경우 하나의 RANGE 로 묶어서 동시 연산(**DEFAULT**)
2. **BETWEEN A AND B**
    1. **시작점 정의**
        1. **CURRENT ROW** : 현재 행부터
        2. **UNBOUNDED PRECENING** : 처음부터(**DEFAULT**)
        3. **N PRECEDING** : N 이전부터
    2. **마지막 시점 정의**
        1. **CURRENT ROW** : 현재 행까지(**DEFAULT**)
        2. **UNBOUNDED FOLLOWING** : 마지막까지
        3. **N FOLLOWING** : N 이후까지

### 순위 관련 함수


**RANK WITHIN GROUP**

- 특정값에 대한 순위 확인
- 윈도우 함수가 아닌 일반함수

**RANK OVER :** 순위 스킵

- 전체 / 특정 그룹 중 값의 순위 확인
- ORDER BY 절 필수
- 순위를 구할 대상을 ORDER BY 절에 명시(여러 개 나열 가능)
- 그룹 내 순위 구할 시 PARTITION BY 절 사용

**DENSE_RANK**

- 누적 순위
- 값이 같을 때 동일한 순위 부여 후 다음 순위가 바로 이어지는 순위 부여 방식

**ROW_NUMBER**

- 연속된 행 번호
- 동일한 순위 인정하지 않고 단순히 순서대로 나열한  순서 값 리턴

**LAG, LEAD**

- 행 순서대로 이전 값(LAG), 이후 값(LEAD) 가져오기

**NTILE**

- 행을 특정 컬럼 순서에 따라 정해진 수의 그룹으로 나누기 위한 함수
- 그룹 번호가 리턴됨
- ORDER BY 필수
- PARTITION BY 를 사용하여 특정 그룹을 또 원하는 수만큼 그룹 분리 가능

### 비율 관련 함수


**RATIO_TO_REPORT**

- 각 값의 비율 리턴(전체 비율 또는 특정 그룹 내 비율 가능)
- ORDER BY 사용 불가

**CUME_DIST :** 누적 비율

- ORDER BY 필수(누적 비율을 구하는 순서 정할 수 있음)

**PERCENT_RANK**

- 분위수 출력
- 전체 COUNT 중 상대적 위치 출력
- ORDER BY 필수

### **TOP N QUERY**


페이징 처리를 효과적으로 수행하기 위해 사용


전체 결과에서 특정 N개 추출


예) 성적 상위 세 명


### **TOP N 행 추출 방법**

1. ROWNUM
2. RANK
3. FETCH

### ROWNUM


출력된 데이터 기준으로 행 번호 부여


절대적인 행 번호가 아닌 가상의 번호이므로 특정 행을 지정할 수 없음(= 연산 불가)


첫 번째 행이 증가한 이후 할당되므로 > 연산 사용 불가 (**작다, 작거나 같다** 만 사용 가능)


### FETCH


출력될 행의 수를 제한하는 절


ORACLE 12C 이상 부터 제공(이전 버전에는 ROWNUM 주로 사용)


SQL-SERVER 사용 가능


ORDER BY 절 뒤에 사용(내부 파싱 순서도 ORDER BY 뒤)


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-8de7c07f5c1a.png)


**OFFSET** : 건너뛸 행의 수 ex) 성적 높은 순 1등 제외, 나머지 3명


**N** : 출력할 행의 수


**FETCH** : 출력할 행의 수를 전달하는 구문


**FIRST** : OFFSET 을 쓰지 않았을 때 처음부터 N 행 출력 명령


**NEXT** : OFFSET 을 사용했을 경우 제외한 행 다음부터 N 행 출력 명령


**ROW | ROWS** : 행의 수에 따라 하나일 경우 단수, 여러 값이면 복수형(특별히 구분 안해도 됨)


## 계층형 질의


PRIOR의 위치에 따라 연결하는 데이터가 달라짐


**START WITH**, **PRIOR**


### 계층형 질의 가상함수


CONNECT_BY_ROOT 컬럼명 : 루트노드의 해당 컬럼명의 값이 출력됨


SYS_CONNECT_BY_PATH(컬럼, 구분자) : 이어지는 경로 출력


ORDER SIBLINGS BY 컬럼 : 같은 레벨일 경우 정렬 수행


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-a5e1076996ab.png)


## PIVOT UNPIVOT


### 데이터의 구조


**LONG DATA(TIDY DATA)** : 하나의 속성이 하나의 컬럼으로 정의되어 값들이 여러 행으로 쌓이는 구조, RDBMS 의 테이블 설계 방식, 다른 테이블과 조인 연산이 가능한 구조


**WIDE DATA(CROSS TABLE)** : 행과 컬럼에 유의미한 정보 전달을 목적으로 작성하는 교차표, 하나의 속성값이 여러 컬럼으로 분리되어 표현, RDBMS에서 WIDE 형식으로 테이블 설계 시 값이 추가될 때마다 컬럼이 추가돼야 하므로 비효율적, 다른 테이블과의 조인 연산이 불가능함, 주로 데이터를 요약할 목적으로 사용


### 데이터 구조 변경


**PIVOT** : LONG → WIDE


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-d729ee2aab67.png)


**UNPIVOT** : WIDE → LONG


![Untitled.png](/aibOS/public/images/posts/28e0a7f9-6ad3a706d2f0.png)


### PIVOT


교차표를 만드는 기능


STACK, UNSTACK, VALUE 컬럼 정의가 중요


FROM 절에 STACK, UNSTACK, VALUE 컬럼명만 정의 필요(필요 시 서브쿼리 사용하여 필요 컬럼 제한)


PIVOT 절에 UNSTACK, VALUE 컬럼명 정의


PIVOT 절 IN 연산자에 UNSTACK 컬럼 값을 정의


FROM 절에 선언된 컬럼 중 PIVOT 절에서 선언한 VALUE 컬럼, UNSTACK 컬럼을 제외한 모든 컬럼은 STACK 컬럼이 됨


{% raw %}
```sql
SELECT *
	FROM 테이블명 또는 서브쿼리
	PIVOT (VALUE 컬럼명 FOR UNSTACK 컬럼명 IN (값1, 값2, 값3));
```
{% endraw %}


### UNPIVOT


WIDE 데이터를 LONG 데이터로 변경하는 문법


STACK 컬럼 : 이미 UNSTACK 되어 있는 여러 컬럼을 하나의 컬럼으로 STACK 시 새로 만들 컬럼이름(사용자 정의)


VALUE 컬럼 : 교차표에서 셀 자리(VALUE) 값을 하나의 컬럼으로 표현하고자 할 때 새로 만들 컬럼명(사용자 정의)


값1, 값2, … : 실제 UNSTACK 되어 있는 컬럼 이름들


{% raw %}
```sql
SELECT *
	FROM 테이블명 또는 서브쿼리
	UNPIVOT (VALUE 컬럼명 FOR STACK 컬럼명 IN (값1, 값2, ...))
```
{% endraw %}


### 정규 표현식


문자열의 공통된 규칙을 보다 일반화하여 표현하는 방법

