---
layout: post
title: "이메일 로깅"
date: 2026-01-15
categories: [general]
tags: [Java]
excerpt_separator: ""
---



원래는 이메일 로그를 버퍼랑 큐 사용해서 비동기로 처리하고 있었다


근데 우리 프로젝트는 몇천 건까지 발송할 일은 없어서 대표님이 오버 엔지니어링이라고 하셨다


그래서 배치인서트만 하는걸로 변경했다


**이전 방식**

- 버퍼에 쌓음 → 큐에 넣음 → 비동기 배치 인서트

**변경 후**

- 이메일 발송 완료 후 한 번에 배치 인서트

### 구현 코드


{% raw %}
```java
@Override
public void sendEmailToMultipleRecipients(String[] emails, String subject, String content, String contentText) {
    if (emails == null || emails.length == 0) {
        log.warn("수신자 이메일이 없습니다");
        return;
    }
    
    List<EmailSendLog> emailLogList = new ArrayList<>();

    // 1. 이메일 발송 처리
    for (String email : emails) {
        String[] emailParts = email.split("@");
        if (emailParts.length != 2) {
            log.warn("잘못된 이메일 형식: {}", email);
            continue;
        }

        EmailSendLog logDto = new EmailSendLog();
        logDto.setEmlLocal(emailParts[0]);
        logDto.setEmlDmn(emailParts[1]);
        logDto.setTitle(subject);
        logDto.setContent(content);
        logDto.setContentText(contentText);

        try {
            EmailMessage singleEmailMessage = EmailMessage.builder()
                    .to(new String[]{email})
                    .subject(subject)
                    .content(content)
                    .build();

            emailService.sendEmail(singleEmailMessage);
            logDto.setSendResultCd(SendResultCd.SUCCESS.name());

        } catch (Exception e) {
            log.error("이메일 전송 실패: {}", email, e);
            String failReason = e.getMessage() != null ? e.getMessage() : "이메일 전송 중 오류 발생";
            if (failReason.length() > 255) {
                failReason = failReason.substring(0, 252) + "...";
            }
            logDto.setSendResultCd(SendResultCd.FAIL.name());
            logDto.setFailReason(failReason);
        }
        
        emailLogList.add(logDto);
    }

    // 2. DB에 배치로 저장
    saveEmailLogs(emailLogList);
}

@Transactional
private void saveEmailLogs(List<EmailSendLog> emailLogList) {
    if (emailLogList.isEmpty()) {
        return;
    }
    
    try {
        // 사용자 정보 조회
        List<EgovMap> userInfoList = emailSendLogMapper.selectUsersByEmails(emailLogList, aesComponent.getSecretKey());
        Map<String, EgovMap> userInfoMap = new HashMap<>();
        
        if (userInfoList != null) {
            for (EgovMap userInfo : userInfoList) {
                String emlLocal = (String) userInfo.get("emlLocal");
                String emlDmn = (String) userInfo.get("emlDmn");
                if (emlLocal != null && emlDmn != null) {
                    userInfoMap.put(emlLocal + "@" + emlDmn, userInfo);
                }
            }
        }

        // 사용자 정보 설정 및 암호화
        for (EmailSendLog emailLog : emailLogList) {
            if (emailLog.getEmlLocal() != null && emailLog.getEmlDmn() != null) {
                String emailKey = emailLog.getEmlLocal() + "@" + emailLog.getEmlDmn();
                EgovMap userInfo = userInfoMap.get(emailKey);
                if (userInfo != null) {
                    emailLog.setUserId((String) userInfo.get("userId"));
                    emailLog.setUserNm((String) userInfo.get("userNm"));
                }
            }
            cryptoUtil.encrypt(emailLog);
        }

        int result = emailSendLogMapper.insertEmailSendLogBatch(emailLogList);
        log.info("이메일 로그 저장 완료. 건수: {}", result);
        
    } catch (Exception e) {
        log.error("이메일 로그 저장 실패. 건수: {}", emailLogList.size(), e);
        // 로그 저장 실패가 이메일 전송 성공에 영향 주면 안되니까 예외는 여기서 처리
    }
}
```
{% endraw %}


### 트랜잭션 처리


**이메일 전송**

- 트랜잭션 없음
- 외부 시스템(SMTP) 호출이라 트랜잭션 걸면 안됨
- 각 이메일별로 성공/실패 처리

**DB 저장**

- `@Transactional` 적용
- 배치 인서트 중 오류 나면 전체 롤백
- 로그 저장 실패해도 이메일 전송 결과에는 영향 없음
