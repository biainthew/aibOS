---
layout: post
title: "포인터 기본"
date: 2025-10-03
categories: [general]
tags: [C]
excerpt_separator: ""
---



## 1. 배열의 주소 구조


### 배열 선언과 메모리 구조


```c
int data[] = {3, 17, 9, 12, 5, 15, 8, 20};
```


**data[0]의 주소를 100으로 가정하면:**

- `data[0]` 주소: 100 (값: 3)
- `data[1]` 주소: 104 (값: 17)
- `data[2]` 주소: 108 (값: 9)
- `data[3]` 주소: 112 (값: 12)
- `data[4]` 주소: 116 (값: 5)
- `data[5]` 주소: 120 (값: 15)
- `data[6]` 주소: 124 (값: 8)
- `data[7]` 주소: 128 (값: 20)
> int는 4바이트이므로 주소가 4씩 증가

---


## 2. 배열 이름의 특성


### 배열 이름은 포인터 상수


```c
int data[] = {3, 17, 9, 12, 5, 15, 8, 20};
```


**중요 개념:**

- `data`의 값 = 100 (배열 첫 번째 요소의 주소)
- `data` 자체의 주소 = 없음
- 배열 이름은 **포인터 상수**이므로 별도의 주소를 갖지 않음

**일반 변수와의 차이:**


```c
int x = 10;
```

- `x`의 값: 10
- `x`의 주소(`&x`): 예) 200번지

```c
int data[] = {3, 17, 9};
```

- `data` = 100 (주소값 자체)
- `data`의 별도 주소 없음

---


## 3. 포인터 연산


### 기본 포인터 연산


```c
int data[] = {3, 17, 9, 12, 5, 15, 8, 20};
int *ptr = data;  // ptr = 100
```


**예제:**


```c
ptr + 2     // 주소: 108 (100 + 2*4)
*(ptr + 2)  // 값: 9 (108번지의 값)
ptr[2]      // 값: 9 (*(ptr + 2)와 동일)
```


### 배열 표기법 vs 포인터 표기법

- `ptr[3]` = `(ptr + 3)` (완전히 동일)
- 배열 표기법은 포인터 표기법의 편의 문법

---


## 4. 포인터끼리 빼기


### 포인터 간 뺄셈의 의미


```c
int *ptr1 = data + 1;  // 104 (data[1])
int *ptr2 = data + 4;  // 116 (data[4])

ptr2 - ptr1  // 결과: 3
```


**핵심 규칙:**

- 포인터 - 포인터 = **요소 개수 차이** (바이트가 아님)
- 실제 계산: (116 - 104) ÷ 4 = 3개
- C언어가 자동으로 자료형 크기를 고려해서 계산

**왜 요소 개수를 반환할까?**

- "몇 바이트 떨어졌나"보다 "몇 개의 요소가 있나"가 더 유용
- 자료형이 바뀌어도 일관된 정보 제공 (int든 double이든 동일하게 3개)

---


## 5. 포인터 연산 정리


### 연산 종류별 의미


| 연산            | 의미                | 예시                 |
| ------------- | ----------------- | ------------------ |
| `포인터 + 정수`    | 주소값 증가 (자료형 크기만큼) | `ptr + 3` → 주소 112 |
| `포인터 - 정수`    | 주소값 감소 (자료형 크기만큼) | `ptr - 1` → 주소 96  |
| `포인터 - 포인터`   | **요소 개수 차이**      | `ptr2 - ptr1` → 3  |
| `*(포인터 + 정수)` | 해당 위치의 값          | `*(ptr + 3)` → 12  |
| `포인터[정수]`     | 해당 위치의 값          | `ptr[3]` → 12      |


---


## 6. 핵심 포인트


### 꼭 기억할 것

1. 배열 이름은 포인터 상수 (첫 번째 요소의 주소)
2. int는 4바이트 → 주소는 4씩 증가
3. `ptr[i]` = `(ptr + i)` (동일 표현)
4. **포인터끼리 빼면 요소 개수 반환**

### 자주 나오는 함정

- 포인터 뺄셈: 바이트 차이가 아닌 요소 개수
- 배열 이름의 주소: 별도로 존재하지 않음
- 포인터 연산 시 자료형 크기 자동 반영
