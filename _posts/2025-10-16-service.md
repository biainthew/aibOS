---
layout: post
title: "Service"
date: 2024-10-02
categories: [general]
tags: [Java]
---


### 역할

1. 비즈니스 규칙을 중심으로 **비즈니스 로직**을 구현한다 ex) 사용자의 주문을 처리, 데이터 베이스에서 여러 데이터를 조합하여 가공하는 작업 수행
2. Controller와 Repository(or DAO) 간의 **중간 역할**
    1. Controller는 주로 사용자 요청을 받고 그 요청을 Service로 전달한다 Service는 이 요청을 처리하고 필요한 데이터를 Repository에서 조회하거나 데이터를 저장한 뒤 결과를 Controller에 전달한다
3. 비즈니스 로직이 여러 곳에서 사용될 수 있을 때 **동일한 로직을 Service 계층에 구현**해 놓으면 여러 Controller나 다른 서비스들이 하나의 비즈니스 로직을 호출할 수 있다
4. Service 계층은 주로 데이터베이스 작업과 같은 중요한 비즈니스 로직을 다루기 때문에 **트랜잭션을 관리**하는 데 중요한 역할을 한다
    1. 예를 들어 여러 데이터베이스 작업을 하나의 트랜잭션으로 묶어야 할 때 Service 계층에서 트랜잭션을 시작하고 종료하며 실패 시 롤백하는 등의 작업을 수행한다

### 예시


```java
@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private PaymentService paymentService;

    public Order createOrder(User user, Cart cart) {
        // 주문 생성
        Order order = new Order(user, cart.getItems());
        
        // 결제 처리
        boolean paymentSuccessful = paymentService.processPayment(user, order.getTotalAmount());
        if (!paymentSuccessful) {
            throw new PaymentFailedException("결제가 실패했습니다.");
        }

        // 주문 저장
        orderRepository.save(order);
        
        return order;
    }
}
```


```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private EmailService emailService;

    @Transactional
    public void registerUser(UserDto userDto) {
        // 새로운 사용자 생성
        User user = new User(userDto.getUsername(), userDto.getPassword(), userDto.getEmail());

        // 사용자 저장
        userRepository.save(user);

        // 환영 이메일 전송
        emailService.sendWelcomeEmail(user.getEmail());
    }
}
```


### 왜 ?

1. 비즈니스 로직을 명확히 **분리**하여 코드의 **응집도**를 높이고 **재사용성과 유지보수성**을 개선하기 위해
2. **트랜잭션 관리**를 통해 데이터 일관성을 유지하고 **코드 중복을 방지**하며 테스트 및 유지보수를 용이하게 만든다
