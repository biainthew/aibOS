---
layout: post
title: "Index"
date: 2025-04-29
categories: [general]
tags: [Sql]
excerpt_separator: ""
---



{% raw %}
```sql
SELECT * FROM users WHERE name = '이영희';
```
{% endraw %}

- 위 처럼 코드를 작성하면 DB는 테이블을 맨 위부터 한 줄씩 전부 다 확인 -> 풀스캔
- 하지만 name 컬럼에 인덱스를 만들어두면 DB는 전체 테이블을 스캔하지 않고 인덱스를 먼저 뒤져서 값이 어디에 있는지 빠르게 찾음

{% raw %}
```sql
CREATE INDEX idx_users_name ON users(name);
```
{% endraw %}


### 언제 필요한지 ?

- WHERE, JOIN, ORDER BY, GROUP BY 절에 자주 사용되는 컬럼일 때
- 테이블의 데이터 양이 많을 때

### 주의할 점

- 인덱스가 너무 많으면 오히려 INSERT/UPDATE 성능 저하 발생할 수 있음
- 자주 바뀌는 컬럼에는 인덱스 남발 X
- 함수나 연산이 들어가면 인덱스가 무시될 수 있음

### 데이터베이스 내부적으로는 ?

- DB도 실제로는 데이터를 페이지(블록) 단위로 저장
- 인덱스를 만들면 DB는 트리 구조 (보통 B-Tree)로 색인표를 만들어 둡니다.

{% raw %}
```less
[김, 박, 이]
            /   |    \
         ...  박OOO   이OOO
```
{% endraw %}


→ `WHERE name = '박지민'` 이라고 하면:

1. 루트에서 '박' 쪽 분기점으로 이동
2. 해당 블록 안에서 빠르게 '박지민' 찾음
3. 이 레코드의 실제 위치를 알고 있으므로 바로 해당 위치로 이동해서 데이터 읽음

### 인텔리제이 실행 계획


**작업 (Operation)**


: DB가 어떤 작업을 수행하는지 나타냄 (예. TABLE ACCESS FULL, INDEX FANGE SCAN)


**매개변수 (Options)**


: 작업의 추가 조건 또는 방식 (예. FULL, BY INDEX ROWID, UNIQUE)


**행 (Rows)**


: 오라클이 예상하는 결과 행 수 (예측치, 실제와 다를 수 있음)


**총 비용 (Cost)**


: 오라클의 옵티마이저가 판단한 이 작업의 상대적인 비용 (낮을수록 좋음)


**원시 설명 (Object Name)**


: 실제 액세스 대상이 되는 테이블 이름, 인덱스 이름 등 객체명

