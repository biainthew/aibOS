---
layout: post
title: "[SQLD]2-2. SQL 활용"
date: 2024-03-02
categories: [general]
tags: [Test]
excerpt_separator: ""
---



## 표준 조인


### STANDARD SQL 개요


표준 SQL의 기능


STANDARD JOIN 기능 추가(CROSS, OUTER JOIN 등 새로운 FROM 절 JOIN 기능들)


SCALAR SUBQUERY, TOP N QUERY 등의 새로운 서브쿼리 기능들


ROLLUP, CUBE, GROUPING SETS 등의 새로운 리포팅 기능


WINDOW FUNCTION 같은 새로운 개념의 분석 기능들


### 일반 집합 연산자


UINION 연산은 UNION 기능으로


INTERSECTION 연산은 INTERSECT 기능으로


DIFFERENCE 연산은 EXCEPT 기능으로 (O MINUS)


PRODUCT 연산은 CROSS JOIN 기능으로


### 순수 관계 연산자


SELECT 연산은 WHERE 절로 구현


PROJECT 연산은 SELECT 절로 구현


(NATURAL) JOIN 연산은 다양한 JOIN 기능으로 구현


DIVIDE 연산은 현재 사용되지 않는다


### FROM 절의 JOIN 형태


ANSI/ISO SQL 에서 표시하는 FROM 절의 JOIN 형태는 다음과 같다


INNER / NARAL / USING / ON / CROSS / OUTER


ANSI/ISO 에서 규정한 JOIN 문법은 기존 JOIN 방식과 차이가 있다


기존 WHERE 절 방식을 그대로 사용 가능


추가된 선택 기능으로 FROM 절에서 JOIN 조건을 명시적으로 정의 가능


INNER JOIN은 WHERE 절부터 사용하던 JOIN 의 Default 옵션, 동일값이 있는 행만 반환, Default 옵션이므로 생략이 가능하지만 CROSS JOIN, OUTER JOIN 과는 같이 사용 불가능


NATURAL JOIN INNER JOIN의 하위개념, 두 테이블 간의 동일한 이름을 갖는 모든 컬럼들에 대해 EQUAL JOIN을 수행, NATURAL INNER JOIN 이라고 표시할 수도 있음


과거 WHERE 절에서 JOIN 조건과 데이터 검증 조건이 같이 사용되어 용도가 불분명한 경우가 발생할 수 있었는데 WHERE 절의 JOIN 조건을 FROM 절의 ON 조건절로 분리하여 표시함으로써 사용자가 이해하기 쉽도록 한다


NATURAL JOIN 처럼 JOIN 조건이 숨어있지 않고 명시적으로 JOIN 조건을 구분할 수 있고 NATURAL JOIN 이나 USING 조건절처럼 컬럼명이 똑같아야 한다는 제약 없이 컬럼명이 상호 다르더라도 JOIN 조건으로 사용할 수 있으므로 앞으로 가장 많이 사용될 것으로 예상


FROM 절에 테이블이 많이 사용될 경우 가독성이 떨어지는 단점
→ SQL Server 의 경우 ON 조건절만 지원 / NATURAL JOIN, USING 지원x


### INNER JOIN


내부 조인이라고 하며 JOIN 조건에서 동일한 값이 있는 행만 반환


그동안 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시


USING 조건절이나 ON 조건절을 필수적으로 사용


JOIN 에 사용된 두 테이블의 컬럼이 모두 출력된다


중복 테이블의 경우 별개의 컬럼으로 표시한다


### NATURAL JOIN


두 테이블 간 동일 이름을 갖는 모든 컬럼들에 대해 EQUAL JOIN 수행


NATURAL JOIN 이 명시되면 WHERE 절에서 JOIN 조건 정의 x (USING, ON 조건절)


S 에서는 지원 안함


JOIN 컬럼을 지정하지 않아도 공통된 컬럼으로 JOIN 처리 함


JOIN 에 사용된 컬럼은 같은 데이터 타입이어야 함


ALIAS 나 테이블명과 같은 접두사 붙일 수 없음


별도로 순서를 지정하지 않으면 JOIN의 기준이 되는 컬럼들이 앞쪽에 출력된다


JOIN에 사용된 같은 이름의 컬럼을 하나로 처리한다


### USING 조건절


FROM 절에 USING 조건절을 이용하여 같은 이름의 컬럼 중 원하는 컬럼에 대해서만 EQUAL JOIN을 할 수 있다(NATURAL JOIN은 모든 일치 컬럼, USING은 원하는 컬럼)


S 에서는 지원 안함


JOIN 컬럼에 대해 ALIAS 나 테이블명과 같은 접두사를 붙일 수 없다


JOIN에 참여한 컬럼은 한개로 표시됨


### ON 조건절


ON 조건절을 사용하면 컬럼명이 달라도 JOIN 사용 가능 임의의 조건 사용 가능


이름이 다른 컬럼명을 JOIN 조건으로 사용 가능 JOIN 컬럼 명시 가능


ALIAS 및 테이블명과 같은 접두사 사용 가능


ON 조건절에 데이터 검색 조건을 추가할 수 있다(WHERE 절 사용 권고)


### CROSS JOIN


코드박사의 일반 집합 연산자 중 PRODUCT의 개념


테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합


CARTESIAN PRODUCT, CROSS PRODUCT 와 같은 표현


결과는 양쪽 집합의 M*N 건의 데이터 조합이 발생한다


정상적인 데이터 모델이라면 CROSS JOIN이 필요한 경우는 많지 않지만 간혹 튜닝이나 리포트 작성을 위해 고의적으로 사용하는 경우가 있을 수 있다


그리고 DW의 개별 차원을 사실 컬럼과 JOIN 하기 전에 모든 차원의 CROSS PRODUCT 를 먼저 구할 때 유용하게 사용할 수 있다


### OUTER JOIN


JOIN 조건에서 동일한 값이 없는 행도 반환할 때 사용


+ 표시를 사용했었으나 검색 조건 불명확, I/O 연산자 사용 시 에러 발생


+ 표시가 누락된 컬럼 존재 시 OUTER JOIN 오류 발생, FULL OUTER JOIN 미지원 등 불편함이 많아 STANDARD JOIN을 사용함으로써 많은 문제점 해결 및 호환성 확보


USING, ON 조건절 필수 사용 LEFT.RIGHT의 경우 기준 테이블이 무조건 드라이빙 테이블


### LEFT/RIGHT OUTER JOIN


좌측 테이브렝서 데이터를 먼저 읽은 후 우측 테이블에서 JOIN 대상을 읽어옴


좌측 테이블이 기준이 됨 OUTER 생략 가능


### FULL OUTER JOIN


조인되는 모든 테이블의 데이터를 읽어 JOIN 한다 LEFT/ RIGHT 조인 결과의 합집합


## 집합 연산자


여러개의 데이터를 조회하는 방법 중 하나


여러 개의 질의 결과를 연결하여 하나로 결합하는 방식
→ 두 개 이상의 질의 결과를 하나의 결과로 만들어준다


### **일반적으로 집합 연산자를 사용하는 상황**


서로 다른 테이블에서 유사한 형태의 결과를 반환하는 겻을 하나의 결과로 합치고자 할 때 사용


동일 테이블에서 서로 다른 질의를 수행하여 결과를 합치고자 할 때 사용


이외에도 튜닝 관점에서 실행계획을 분리하고자 하는 목적으로도 사용


### 집합 연산자를 사용하기 위한 제약조건(지키지 않을 시 DB가 오류 반환)


SELECT 절의 컬럼수가 동일


SELECT 절의 동일 위치 컬럼의 데이터 타입이 상호 호환 가능(반드시 동일 필요 x)


### **집합 연산자의 종류**


UNION : 합집합, 중복된 행 하나로 표시


UNION ALL : 합집합, 중복된 행 그대로 표시(단순히 결과만 합쳐놓음) 일반적으로 질의 결과들이 상호 배타적일 때 많이 사용, 중복 없을 시 UNION 과 결과가 동일하다(정렬 순서에는 차이가 있을 수 있음)


INTERSECT : 교집합, 중복된 행 하나로 표시


EXCEPT : 앞의 SQL 결과에서 뒤의 결과를 뺀 차집합, 중복 행 하나로 표시 (O 에서는 MINUS 사용)


SELCT 컬럼명1, 컬럼명2, …
FROM 테이블명1
WHERE 조건식 GROUP BY 컬럼/표현식 HAVING 그룹조건식


### 집합연산자


SELECT 문
ORDER BY 컬럼명 ACS | DESC


집합 연산자는 사용상의 제약조건을 만족한다면 어떤 형태의 SELECT 문이라도 이용이 가능


집합 연산자는 여러개의 SELECT 문을 연결하는 것에 지나지 않음


ORDER BY는 최종 결과에 대한 정렬 처리이므로 가장 마지막 줄에 한 번만


## 계층형 질의와 셀프 조인


### 계층형 질의


테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해 사용


동일 테이블에 계층적으로 상/하위 데이터가 포함된 데이터를 계층형 데이터라 함
ex) 사원 테이블의 사원들 사이에 하위 사원과 상위 사원(관리자) 관계


엔티티를 순환관계 데이터 모델로 설계할 경우 계층형 데이터 발생


계층형 데이터 조회는 DBMS 벤더와 버전에 따라 다른 방법으로 지원한다


### Oracle 계층형 질의


**사용되는 가상 컬럼**


LEVEL : 루트 데이터를 1로 시작하여 하위로 내려갈 수록 Leaf 까지 1씩 증가


CONNECT_BY_ISLEAF : 리프 데이터이면 1 그렇지 않으면 0


CONNECT_BY_ISCYCLE : 자식을 갖는데 해당 데이터가 조상으로서 존재하면 1, 그렇지 않으면 0, CYCLE 옵션 사용시에만 사용 가능


**계층형 질의 구문**


{% raw %}
```javascript
SELECT 컬럼 ...
FROM 테이블
WHERE 조건
START WITH 조건
CONNECT BY [NOCYCLE] 조건 ...
[ORDER SIBLINGS BY 컬럼, ...]
```
{% endraw %}


**START WITH** 절 (엑세스) : 계층 구조 전개의 시작 위치를 지정하는 구문


CONNECT BY 절 (조인) : 다음에 전개될 자식 데이터를 지정하는 구문, 자식 데이터는 CONNECT BY 절 주어진 조건 만족


PRIOR : CONNECt BY 절에 사용되며 현재 읽은 컬럼 지정
PRIOR 자식 = 부모 : [부모 → 자식] 순방향 전개
PRIOR 부모 = 자식 : [자식 → 부모] 역방향 전개


NOCYCLE : 데이터 전개 시 이미 나타났던 동일한 데이터가 전개 중에 다시 나타난다면 이것을 CYCLE 형성이라 함, 사이클이 발생한 데이터는 런타임 오류 발생
→ NOCYCLE 추가 - 사이클 발생 이후의 데이터는 전개 x


ORDER SIBLINGS BY : 형제 노드(동일 Level) 사이에서 정렬


WHERE : 모든 전개를 수행한 후에 지정된 조건을 만족하는 데이터만 추출


**계층형 질의에서 사용되는 함수**


SYS_CONNECT_BY_PATH(컬럼, 경로분리자)
루트 데이터부터 현재 전개할 데이터까지의 경로를 표시


CONNECT_BY_ROOT 컬럼
현재 전개할 데이터의 루트 데이터를 표시, 단항 연산자


### SQL SERVER 계층형 질의


SQL Server 2000 까지는 계층형 질의 문법 지원 x


조직도처럼 계층적 구조 가진 데이터는 저장 프로시저 재귀 호출이나


While 루프 문에서 임시 테이블을 사용하는 등 프로그램 방식으로 전개


SQL Server 2005 버전부터 하나의 질의로 수행 가능


CTE(Common Table Expression)를 재귀 호출함으로써 상위부터 하위 방향 전개


{% raw %}
```javascript
WITH 테이블명_ANCHOR AS
(SELECT 하위컬럼명, 컬럼명, 상위컬럼명, 0 AS LEVEL)
FROM 테이블명
WHERE 상위컬럼명 IS NULL //재귀 호출의 시작점
UNION ALL
SELECT R.컬럼명, R.계층컬럼명, A.LEVEL + 1
FROM 테이블명_ANCHOR A, 테이블명 R
WHERE A.하위컬럼 = R.상위컬럼)
```
{% endraw %}


### 재귀적 쿼리의 처리 과정

1. CTE 식을 앵커 멤버와 재귀 멤버로 분할
2. 앵커 멤버를 실행하여 첫 번째 호출 또는 기본 결과 집합 T(0) 생성
3. T(i)는 입력으로 사용하고 T(i)+1은 출력으로 사용하여 재귀 멤버 실행
4. 빈 집합이 반환될 때까지 3단계 반복
5. 결과 집합을 반환 T(0)에서 T(n)까지의 UNION ALL

앵커 멤버가 시작점이자 Outer 집합이 되어 Inner 집합인 재귀 멤버와 조인 시작


앞서 조인한 결과가 다시 Outer 집합이 되어 재귀 멤버와 조인을 반복


조인 결과가 비어 있으면(더 조인할 수 없으면) 지금까지 결과 집합 합쳐 리턴


계층 구조를 단순히 하위 방향으로 전개했을 뿐 조직도(실제)와는 다른 모습


조직도와 같은 모습으로 출력하려면 ORDER BY 절 추가해 원하는 순서로 정렬
→ 정렬 기준으로 삼을 수 있는 정렬용 컬럼 추가하여 ORDER BY 조건 추가
(앵커 멤버와 재귀 멤버 양쪽에서 Convert 함수 등으로 데이터 형식 일치)


### 셀프 조인


동일 테이블 사이의 조인(From 절에 동일 테이블이 두 번 이상 나타남)


테이블과 컬럼명이 모두 동일하기 때문에 식별을 위해 반드시 ALIAS 사용


컬럼에도 모두 테이블 ALIAS를 사용해서 어느 테이블의 컬럼인지 식별


이외 나머지 사항은 조인과 동일


{% raw %}
```javascript
SELECT ALIAS명 1.컬럼명1, ALIAS명2.컬럼명1, ...
FROM 테이블명 ALIAS명1, 테이블명 ALIAS명2
WHERE ALIAS명1.컬럼명2 = ALIAS명2.컬럼명1
```
{% endraw %}


OUTER JOIN을 이용해서 상위가 존재하지 않는 데이터까지 모두 결과 표시 가능


## 서브쿼리


### 정의


하나의 SQL문 안에 포함되어 있는 또 다른 SQL 문을 말한다


### 서브쿼리 사용 시 주의사항


서브쿼리를 괄호로 감싸서 사용


서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용이 가능하다


    단일 행 비교 연산자 : 서브쿼리의 결과가 반드시 한 건 이하


    복수 행 비교 연산자 : 서브쿼리의 결과 건수와 상관 없다


서브쿼리에서는 ORDER BY 를 사용하지 못한다 ORDER BY 절은 SELECT 절에서 오직 한 개만 올 수 있기 때문에 메인 쿼리의 마지막 문장 위치


### 서브쿼리가 SQL 문에서 사용이 가능한 곳


SELECT 절, FROM 절, WHERE 절, HAVING 절, ORDER BY 절, INSERT 문의 VALUES 절, UPDATE 문의 SET 절


### 동작 방식에 따른 서브쿼리 분류


Un-Correlated(비연관) 서브쿼리 : 서브쿼리가 메인쿼리 컬럼을 갖고 있지 않은 형태, 메인쿼리에 값을 제공하기 위한 목적으로 주로 사용


Correlated(연관) 서브쿼리 : 서브쿼리가 메인쿼리 컬럼을 가지고 있는 형태, 일반적으로 메인쿼리가 먼저 수행되어 얽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자 할 때 주로 사용


### 반환되는 데이터의 형태에 따른 서브쿼리 분류


Single Row(단일 행) : 서브쿼리 결과가 항상 한 건 이하인 서브쿼리, 단일행 비교 연산자와 함께 사용(등호, 부등호)


Multi Row(다중 행) :  실행 결과가 여러 건인 서브쿼리, 다중 행 비교 연산자와 함께 사용(IN, ALL, ANY, SOME, EXISTS)


Multi Column(다중 컬럼) : 실행 결과로 여러 컬럼을 반환, 메인쿼리의 조건절에 여러 컬럼을 동시에 비교 가능, 서브쿼리와 메인쿼리에서 비교하고자 하는 컬럼


Correlated(연관) 서브쿼리 : 서브쿼리 내에 메인쿼리 컬럼이 사용된 서브쿼리


### 그 밖의 위치에서 사용하는 서브쿼리


SELECT 절에 서브쿼리 사용
→ 스칼라 서브쿼리 : 한 행, 한 컬럼만을 반환


FROM 절에서 서브쿼리 사용
→ 인라인 뷰 : SQL 문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 DB에 해당 정보가 저장되지 않음, 그래서 일반 뷰를 정적 뷰라고 하고 인라인 뷰를 동적 뷰라고 한다


HAVING 절에서 서브쿼리 사용
→ 서브쿼리를 사용한 변경 작업을 할 때 서브쿼리 결과가 NULL을 반환할 경우 해당 컬럼의 결과가 NULL이 될 수 있기 때문에 주의
INSERT 문의 VALUES 절에서 사용


### 뷰


테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않다


뷰는 단지 뷰의 정의만을 가지고 있다, 질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성하여 수행한다, 뷰는 실제 데이터를 가지고 있지 않지만 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블 이라고도 한다


**뷰의 장점**


    독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경 안됨


    편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성 가능, 또한 해당 형태의 SQL문을 자주 사용할 때 뷰를 이용하면 편리


    보안성 : 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면 뷰를 생성할 때 해당 컬럼을 빼고 생성하여 사용자에게 정보를 감추기 가능


## 그룹함수


### 데이터 분석 개요


AGGREGATE FUNCTION : GROUP AGGREGATE FUNCTION 이라고도 부르며 GROUP FUNCTION 의 한 부분으로 분류할 수있다 각종 집계 함수들이 포함되어 있다


GROUP FUNCTION 


    ROLLUP은 GROUP BY의 확장된 형태로 사용하기가 쉬우며 병렬로 수행이 가능하기 때문에 매우 효과적일 뿐 아니라 시간 및 지역처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합하도록 되어 있다


    CUBE는 결합 가능한 모든 값에 대하여 다차원적인 집계를 생성하게 되므로 ROLLUP에 비해 다양한 데이터를 얻는 장점이 있는 반면 시스템에 부하를 많이 주는 단점이 있다


    GROUPING SETS는 원하는 부분의 소계만 손쉽게 추출할 수 있는 장점이 있다


    ROLLUP, CUBE, GROUPING SETS 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 정렬 컬럼을 명시해야 한다


WINDOW FUNCTION : 분석함수나 순위함수로도 알려져있는 윈도우 함수는 DW에서 발전한 기능이며 다음 절에서 자세히 설명


### ROLLUP 함수


ROLLUP에 지정된 Grouping columns 의 list는 Subtotal 을 생성하기 위해 사용되며 Grouping Columns 의 수를 N이라고 했을 때 n+1 level의 subtotal 이 생성된다
→ 인수1로 묶인 인수2의 계, 인수2로 묶인 인수 3의 계, … 총 합계


ROLLUP의 인수는 계층 구조이므로 순서가 바뀌면 수행 결과도 바뀌니 순서에 주의


GROUP BY 절에 인수를 묶어서 사용 → GROUP BY ROLLUP (인수1, 인수2, ,,,)


GROUPING 함수 사용 : GROUPING(EXPR) = (소계 결과 1 / 그 외에는 0), CASE/DECODE를 함께 사용해 소계 필드에 원하는 문자열 지정 가능하여 보고서 작성시유용하게 사용 가능


### CUBE 함수


ROLLUP 에서는 단지 가능한 Subtotal 만을 생성하였지만 CUBE는 결합 가능한 모든 값에 대하여 다차원 집계를 생성한다


CUBE를 사용할 경우에는 내부적으로는 Grouping Columns 의 순서를 바꾸어서 또 한번의 Query 를 추가 수행해야 한다


뿐만 아니라 Grand Total 은 양 쪽의 Query 에서 모두 생성이 되므로 한 번의 Query 에서는 제거 되어야 하기 때문에 ROLLUP에 비해 시스템 연산 대상이 많다


이처럼 Grouping columns 가 가질 수 있는 모든 경우에 대하여 Subtotal 을 생성해야 하는 경우에는 CUBE 사용이 바람직하나 ROLLUP에 비해 시스템에 많은 부하를 주므로 사용에 주의해야 한다


CUBE 함수의 경우 표시된 인수들에 대한 계층별 집계를 구할 수 있으며 이 때 표시된 인수들 간에는 계층 구조인 ROLLUP과는 달리 평등한 관계이므로 인수의 순서가 바뀌는 경우 행간에 정렬 순서는 바뀔 수 있어도 데이터 결과는 같다


GROUP BY 절에 인수를 묶어 사용 → GROUP BY CUBE(인수1, 인수2, …)


### GROUPING SETS


더욱 다양한 소계 집합을 만들 수 있다 GROUP BY 문장을 여러번 반복하지 않아도 원하는 결과를 쉽게 얻을 수 있다 표시된 인수들에 대한 개별 집계를 구할 수 있으며 이 때 표시된 인수들 간에는 계층구조인 ROLLUP 과는 달리 평등한 관계이므로 인수의 순서가 바뀌어도 결과는 같다 결과에 대한 정렬이 필요한 경우 ORDER BY 절에 명시


UNION ALL을 사용한 일반 그룹함수를 사용한 SQL과 같은 결과를 얻을 수 있으며 괄호로 묶은 집합 별로 집계를 구할 수 있다(괄호 내는 계층 구조 없음)


일반 그룹함수를 이용한 SQL과 결과는 같으나 행들의 정렬 순서는 다를 수 있다 


GROUP BY 절에 인수를 묶어 사용 → GROUP BY GROUPING SETS(인수, 인수)


## 윈도우 함수


### 개요


행과 행 간의 관계를 쉽게 정의하기 위한 함수


### 종류


순위 : RANK, DENSE_RANK, ROW_NUMBER


집계 : SUM, MAX, MIN, AVG, COUNT, (SQL Server 집계함수 OVER 절 내의 ORDERBY 구문 지원 안함)


행 순서 : FIRST_VALUE, LAST_VALUE, LAG, LEAD


비율 : CUME_DIST, PERCENT_RANK, NTILE, RATIO_TO_REPORT


### 신택스


윈도우 함수에는 OVER 문구가 필수적으로 포함


{% raw %}
```javascript
SELECT 컬럼명, 컬럼명,...
WINDOW FUNTION(ARGUMENTS)
OVER ([PARTITION BY 컬럼] [ORDER BY 절] [WINDOWING 절]) ALIAS
FROM 테이블명
```
{% endraw %}


ARGUMENTS : 함수에 따라 0~n 개의 인수


PARTITION BY 절 : 전체 집합을 기준에 의해 소그룹으로 나눌 수 있다


ORDER BY 절 : 어떤 항목에 대해 순위를 지정할 지 ORDER BY 절을 기술한다


WINDOWING 절 : 함수의 대상이 되는 행 기준의 범위를 강력히 지정 가능
→ ROWS 물리적인 결과 행수/ RANGE 논리적인 값에 의한 범위 [S 는 지원 안함]


### 그룹 내 순위함수


RANK 함수 : 특정 항목(컬럼), 특정 범위(파티션), 전체 데이터에 대한 순위를 구하는 함수, 동일한 값에 대해서는 동일한 순위(다음 순위 스킵)


DENSE_RANK 함수 : RANK 와 흡사하나 동일한 순위를 하나의 건수로 취급(스킵 안함)


ROW_NUMBER 함수 : 동일한 값이라도 고유한 순위를 부여


### 일반 집계함수


SUM : 파티션별 윈도우의 합(같은 ORDER BY 순서 경우 합쳐서 계산)


MAX : 파티션별 윈도우의 최대값


MIN : 파티션별 윈도우의 최소값


AVG : 파티션별 윈도우의 평균값


### 그룹 내 행 순서함수 (S x)


FIRST_VALUE : 파티션 별 윈도우의 최초로 나온 값, MIN을 이용하여 같은 결과 가능(공통 등수 인정 안함)


LAST_VALUE : 파티션별 윈도우의 가장 마지막에 나온 값, MAX 이용하여 같은 겨로가 가능(공동 등수 인정 안함)


공동 등수 의도적으로 정렬하고 싶다면 인라인 뷰, ORDER BY 조건 이용


LAG : 파티션별 윈도우에서 이전 몇 번째 행의 값, LAG(인수, 몇행 앞, 없는 경우 반환)


LEAD : 파티션별 윈도우에서 이후 몇 번째 행의 값 LEAD(인수, 몇행 뒤, 없는 경우 반환)


### 그룹 내 비율 함수 (S x)


RATIO_TO_REPORT : 파티션 내 전체 SUM 값에 대한 행별 컬럼 값의 백분율을 소수점으로 반환, 개별 RATIO 합을 구하면 1


PERCENT_RANK : 파티션별 윈도우에서 제일 먼저 나오는 것 0, 제일 늦게 나오는 것 1로 하여 값이 아닌 행의 순서별 백분율 반환, 같은 ORDER 순서 인정 → 앞 행의 결과 값을 기준으로 삼음


CUME_DIST : 파티션별 윈도우의 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율, 같은 ORDER 순위 인정 → 뒤 행의 결과값을 기준으로 삼음


NTILE : 파티션별 전체 건수를 ARGUMENT 값으로 n등분 한 결과 , 나머지는 앞의 그룹부터 할당

