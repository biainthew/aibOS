---
layout: post
title: "포인터 배열과 문자열의 관계"
date: 2025-10-03
categories: [general]
tags: [C]
excerpt_separator: ""
---



## 1. 포인터 배열의 기본 개념


### 포인터 배열이란?


{% raw %}
```c
const char *arr[] = {"AB", "CD", "EF"};
```
{% endraw %}


**핵심:**

- 포인터 배열은 **포인터들을 담는 배열**
- 각 배열 요소는 포인터(주소값)를 저장

---


## 2. 메모리 구조 이해하기


### 문자열 리터럴과 포인터 배열


{% raw %}
```c
const char *arr[] = {"AB", "CD", "EF"};
```
{% endraw %}


**주소값 가정 (100단위로 시작):**


### 배열 구조 (arr 자체)

- `arr`의 주소: 100
- `arr[0]`의 주소: 100, 값: 1000
- `arr[1]`의 주소: 104, 값: 1100
- `arr[2]`의 주소: 108, 값: 1200

### 실제 문자열 저장 위치

- 1000번지: "AB" → 'A', 'B', '\0'
- 1100번지: "CD" → 'C', 'D', '\0'
- 1200번지: "EF" → 'E', 'F', '\0'

**중요한 점:**
포인터 배열에 문자열 리터럴을 넣으면:

1. 문자열은 메모리 어딘가(읽기 전용 영역)에 자동 저장됨
2. 배열에는 그 문자열의 **시작 주소값**이 저장됨

---


## 3. 접근 방법과 값


### 기본 접근


{% raw %}
```c
const char *arr[] = {"AB", "CD", "EF"};
```
{% endraw %}


| 표현식           | 의미          | 값 (예시) |
| ------------- | ----------- | ------ |
| `arr`         | 배열의 시작 주소   | 100    |
| `arr[0]` (주소) | 첫 번째 요소의 주소 | 100    |
| `arr[0]` (값)  | 첫 번째 문자열 주소 | 1000   |
| `arr[1]` (값)  | 두 번째 문자열 주소 | 1100   |


### 역참조를 통한 접근


| 표현식             | 의미        | 값 (예시) |
| --------------- | --------- | ------ |
| `*(&arr[0])`    | arr[0]의 값 | 1000   |
| `*(arr[0])`     | 1000번지의 값 | 'A'    |
| `*(arr[0] + 1)` | 1001번지의 값 | 'B'    |
| `arr[0][0]`     | 첫 번째 문자   | 'A'    |
| `arr[0][1]`     | 두 번째 문자   | 'B'    |


**핵심 공식:**

- `arr[i][j]` = `(arr[i] + j)` = `(*(arr + i) + j)`

---


## 4. 타입 분석


### 타입의 중요성


{% raw %}
```c
const char *arr[] = {"AB", "CD", "EF"};
const char **ptr = arr;
```
{% endraw %}


**타입 분석:**

1. `arr`의 타입: `const char *[]` (포인터들의 배열)
2. 배열 이름 decay: `const char **` (포인터를 가리키는 포인터)
3. `ptr`의 타입: `const char **`
4. **타입이 일치하므로 대입 가능**

### 단계별 타입 확인


{% raw %}
```c
arr      // const char ** (decay 후)
*arr     // const char *  (문자열 주소)
**arr    // const char    (첫 번째 문자)
```
{% endraw %}


---


## 5. 이중 포인터 활용


### 포인터로 배열 순회하기


{% raw %}
```c
const char *arr[] = {"AB", "CD", "EF", NULL};
const char **ptr = arr;

while (*ptr) {
    printf("%s\n", *ptr);
    ptr++;
}
```
{% endraw %}


**동작 과정:**

1. `ptr` = 100 (arr의 주소)
2. `ptr` = 1000 (arr[0]의 값, "AB"의 주소)
3. `printf("%s", *ptr)` → "AB" 출력
4. `ptr++` → 104로 이동 (arr[1] 위치)
5. `ptr` = 1100 (arr[1]의 값, "CD"의 주소)
6. 반복...

---


## 6. 주요 개념 정리


### 포인터 배열 vs 일반 배열


{% raw %}
```c
// 일반 배열
char str[] = "AB";
// str 안에 'A', 'B', '\0'이 직접 저장됨

// 포인터 배열
const char *arr[] = {"AB", "CD"};
// arr[0]에는 주소값만 저장, 실제 "AB"는 다른 곳에 저장
```
{% endraw %}


### 핵심 차이점


| 구분    | 일반 배열     | 포인터 배열      |
| ----- | --------- | ----------- |
| 저장 내용 | 문자들 직접 저장 | 주소값 저장      |
| 메모리   | 연속된 공간    | 배열과 문자열이 분리 |
| 수정 가능 | 가능        | 불가능 (const) |


---


## 7. 실기 시험 핵심 포인트


### 반드시 기억할 것

1. **포인터 배열의 각 요소는 주소값**
2. **문자열은 별도 메모리 영역에 저장**
3. **`arr[i][j]`** **=** **`(arr[i] + j)`**
4. **배열 이름은** **`const char **`** **타입으로 decay**

### 자주 나오는 함정

- `arr[0]`과 `(arr[0])`의 차이
    - `arr[0]` = 주소값 (예: 1000)
    - `(arr[0])` = 문자 (예: 'A')
- `(&arr[0])`는 `arr[0]`와 동일
- 이중 포인터 `*ptr`의 의미 파악

### 표현식 변환 연습


{% raw %}
```c
arr[0][1]
= *(arr[0] + 1)
= *(*(arr + 0) + 1)
```
{% endraw %}


---


## 8. 예제 코드 분석


### 괄호 검사 함수


{% raw %}
```c
int func(const char *expr) {
    int cnt = 0;
    while (*expr) {              // expr이 가리키는 문자가 '\0'이 아닐 때
        if (*expr == '(')
            cnt++;
        else if (*expr == ')') {
            cnt--;
            if (cnt < 0)
                return 0;
        }
        expr++;                  // 다음 문자로 이동
    }
    return cnt == 0;
}

int main() {
    const char *arr[] = {"()(()())", "())(", "(()(()))(", NULL};
    const char **ptr = arr;      // ptr = 배열 시작 주소

    while (*ptr) {               // *ptr = 문자열 주소 (NULL이 아닐 때)
        printf("%s\n", func(*ptr) ? "True" : "False");
        ptr++;                   // 다음 문자열로 이동
    }
    return 0;
}
```
{% endraw %}


**흐름 정리:**

1. `ptr`은 배열의 각 요소를 순회
2. `ptr`은 현재 문자열의 주소
3. `func(*ptr)`은 해당 문자열을 검사
4. `ptr++`로 다음 문자열로 이동
